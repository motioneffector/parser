<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/parser - Demo</title>
  <style>
/* ============================================
   RESET & BASE
   ============================================ */

*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
  font-size: 1rem;
  line-height: 1.5;
  color: #e6edf3;
  background: #0d1117;
  min-height: 100vh;
}

/* ============================================
   CSS VARIABLES
   ============================================ */

:root {
  /* Backgrounds */
  --bg-primary: #0d1117;
  --bg-secondary: #161b22;
  --bg-tertiary: #21262d;
  --bg-hover: #30363d;

  /* Borders */
  --border-default: #30363d;
  --border-muted: #21262d;

  /* Text */
  --text-primary: #e6edf3;
  --text-secondary: #8b949e;
  --text-muted: #6e7681;
  --text-link: #58a6ff;

  /* Accents */
  --accent-blue: #1f6feb;
  --accent-blue-hover: #388bfd;
  --accent-green: #238636;
  --accent-green-bright: #3fb950;
  --accent-red: #da3633;
  --accent-red-bright: #f85149;
  --accent-yellow: #d29922;
  --accent-yellow-bright: #e3b341;
  --accent-purple: #8957e5;

  /* Spacing */
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 16px;
  --space-lg: 24px;
  --space-xl: 32px;
  --space-xxl: 48px;

  /* Radii */
  --radius-sm: 4px;
  --radius-md: 6px;
  --radius-lg: 8px;
  --radius-xl: 12px;

  /* Typography */
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;
  --font-size-xl: 1.5rem;
  --font-size-xxl: 2rem;

  /* Shadows */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.3);
  --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.4);

  /* Transitions */
  --transition-fast: 0.1s ease;
  --transition-normal: 0.2s ease;
  --transition-slow: 0.3s ease;
}

/* ============================================
   LAYOUT
   ============================================ */

.page {
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--space-xl);
}

/* ============================================
   HEADER
   ============================================ */

.header {
  margin-bottom: var(--space-xxl);
  padding-bottom: var(--space-xl);
  border-bottom: 1px solid var(--border-default);
}

.header-title {
  font-size: var(--font-size-xxl);
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-sm);
}

.header-description {
  font-size: var(--font-size-lg);
  color: var(--text-secondary);
  margin-bottom: var(--space-lg);
}

.header-links {
  display: flex;
  gap: var(--space-md);
}

.header-link {
  display: inline-flex;
  align-items: center;
  gap: var(--space-xs);
  color: var(--text-link);
  text-decoration: none;
  font-size: var(--font-size-sm);
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--radius-md);
  transition: background var(--transition-fast);
}

.header-link:hover {
  background: var(--bg-tertiary);
  text-decoration: underline;
}

/* ============================================
   EXHIBITS
   ============================================ */

.exhibits {
  display: flex;
  flex-direction: column;
  gap: var(--space-xxl);
}

.exhibit {
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-xl);
  overflow: hidden;
}

.exhibit-header {
  padding: var(--space-lg);
  border-bottom: 1px solid var(--border-default);
}

.exhibit-title {
  font-size: var(--font-size-xl);
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-xs);
}

.exhibit-description {
  font-size: var(--font-size-md);
  color: var(--text-secondary);
}

.exhibit-content {
  padding: var(--space-lg);
}

.exhibit-interactive {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-lg);
  min-height: 200px;
  padding: var(--space-lg);
  margin-bottom: var(--space-lg);
}

.exhibit-controls {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  margin-bottom: var(--space-lg);
}

.exhibit-state {
  padding: var(--space-md);
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.exhibit-state-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: var(--space-sm);
}

/* ============================================
   BUTTONS
   ============================================ */

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-xs);
  padding: var(--space-sm) var(--space-md);
  font-size: var(--font-size-sm);
  font-weight: 500;
  border-radius: var(--radius-md);
  border: 1px solid transparent;
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background: var(--accent-blue);
  color: white;
  border-color: var(--accent-blue);
}

.btn-primary:hover:not(:disabled) {
  background: var(--accent-blue-hover);
  border-color: var(--accent-blue-hover);
}

.btn-secondary {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border-color: var(--border-default);
}

.btn-secondary:hover:not(:disabled) {
  background: var(--bg-hover);
}

.btn-danger {
  background: var(--accent-red);
  color: white;
  border-color: var(--accent-red);
}

.btn-danger:hover:not(:disabled) {
  background: var(--accent-red-bright);
}

.btn-success {
  background: var(--accent-green);
  color: white;
  border-color: var(--accent-green);
}

.btn-success:hover:not(:disabled) {
  background: var(--accent-green-bright);
}

.btn-small {
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
}

/* ============================================
   INPUTS
   ============================================ */

.input {
  background: var(--bg-primary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-md);
  padding: var(--space-sm) var(--space-md);
  font-size: var(--font-size-sm);
  color: var(--text-primary);
  transition: border-color var(--transition-fast);
}

.input:focus {
  outline: none;
  border-color: var(--accent-blue);
}

.input::placeholder {
  color: var(--text-muted);
}

.input-mono {
  font-family: var(--font-mono);
}

select.input {
  cursor: pointer;
}

textarea.input {
  resize: vertical;
  min-height: 80px;
  font-family: inherit;
}

/* ============================================
   TOGGLE
   ============================================ */

.toggle {
  display: inline-flex;
  align-items: center;
  gap: var(--space-sm);
  cursor: pointer;
  font-size: var(--font-size-sm);
}

.toggle-switch {
  position: relative;
  width: 40px;
  height: 22px;
  background: var(--bg-hover);
  border-radius: 11px;
  transition: background var(--transition-normal);
}

.toggle-switch::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 3px;
  width: 16px;
  height: 16px;
  background: var(--text-primary);
  border-radius: 50%;
  transition: transform var(--transition-normal);
}

.toggle input {
  display: none;
}

.toggle input:checked + .toggle-switch {
  background: var(--accent-blue);
}

.toggle input:checked + .toggle-switch::after {
  transform: translateX(18px);
}

.toggle-label {
  color: var(--text-secondary);
}

/* ============================================
   TAGS / BADGES
   ============================================ */

.tag {
  display: inline-block;
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  font-weight: 500;
  border-radius: var(--radius-sm);
  background: var(--bg-tertiary);
  color: var(--text-secondary);
}

.tag-blue {
  background: rgba(31, 111, 235, 0.2);
  color: var(--accent-blue-hover);
}

.tag-green {
  background: rgba(35, 134, 54, 0.2);
  color: var(--accent-green-bright);
}

.tag-red {
  background: rgba(218, 54, 51, 0.2);
  color: var(--accent-red-bright);
}

.tag-yellow {
  background: rgba(210, 153, 34, 0.2);
  color: var(--accent-yellow-bright);
}

.tag-purple {
  background: rgba(137, 87, 229, 0.2);
  color: var(--accent-purple);
}

/* ============================================
   TEST RUNNER
   ============================================ */

.test-runner {
  margin-top: var(--space-xxl);
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-xl);
  overflow: hidden;
}

.test-runner-header {
  padding: var(--space-lg);
  border-bottom: 1px solid var(--border-default);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.test-runner-title {
  font-size: var(--font-size-xl);
  font-weight: 600;
}

.test-runner-actions {
  display: flex;
  gap: var(--space-sm);
}

.test-runner-content {
  padding: var(--space-lg);
}

.test-progress {
  margin-bottom: var(--space-lg);
}

.test-progress-bar {
  height: 8px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: var(--space-sm);
}

.test-progress-fill {
  height: 100%;
  background: var(--accent-blue);
  border-radius: 4px;
  transition: width var(--transition-fast);
  width: 0%;
}

.test-progress-fill.success {
  background: var(--accent-green);
}

.test-progress-fill.failure {
  background: var(--accent-red);
}

.test-progress-text {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}

.test-output {
  background: var(--bg-primary);
  border: 1px solid var(--border-muted);
  border-radius: var(--radius-md);
  max-height: 400px;
  overflow-y: auto;
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.test-output-empty {
  padding: var(--space-xl);
  text-align: center;
  color: var(--text-muted);
}

.test-item {
  padding: var(--space-sm) var(--space-md);
  border-bottom: 1px solid var(--border-muted);
  display: flex;
  align-items: flex-start;
  gap: var(--space-sm);
}

.test-item:last-child {
  border-bottom: none;
}

.test-icon {
  flex-shrink: 0;
  font-size: var(--font-size-md);
}

.test-icon.pass {
  color: var(--accent-green-bright);
}

.test-icon.fail {
  color: var(--accent-red-bright);
}

.test-name {
  color: var(--text-primary);
}

.test-error {
  color: var(--accent-red-bright);
  font-size: var(--font-size-xs);
  margin-top: var(--space-xs);
}

.test-summary {
  margin-top: var(--space-lg);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  font-size: var(--font-size-sm);
  display: flex;
  gap: var(--space-lg);
}

.test-summary-item {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}

.test-summary-item.passed {
  color: var(--accent-green-bright);
}

.test-summary-item.failed {
  color: var(--accent-red-bright);
}

.test-summary-item.skipped {
  color: var(--text-muted);
}

/* ============================================
   UTILITY CLASSES
   ============================================ */

.text-primary { color: var(--text-primary); }
.text-secondary { color: var(--text-secondary); }
.text-muted { color: var(--text-muted); }
.text-success { color: var(--accent-green-bright); }
.text-error { color: var(--accent-red-bright); }
.text-warning { color: var(--accent-yellow-bright); }

.font-mono { font-family: var(--font-mono); }

.flex { display: flex; }
.flex-col { flex-direction: column; }
.flex-wrap { flex-wrap: wrap; }
.items-center { align-items: center; }
.justify-between { justify-content: space-between; }
.gap-xs { gap: var(--space-xs); }
.gap-sm { gap: var(--space-sm); }
.gap-md { gap: var(--space-md); }
.gap-lg { gap: var(--space-lg); }

.mt-sm { margin-top: var(--space-sm); }
.mt-md { margin-top: var(--space-md); }
.mt-lg { margin-top: var(--space-lg); }
.mb-sm { margin-bottom: var(--space-sm); }
.mb-md { margin-bottom: var(--space-md); }
.mb-lg { margin-bottom: var(--space-lg); }

.p-sm { padding: var(--space-sm); }
.p-md { padding: var(--space-md); }
.p-lg { padding: var(--space-lg); }

.hidden { display: none; }

/* ============================================
   SCROLLBAR
   ============================================ */

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--bg-hover);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-default);
}

/* ============================================
   EXHIBIT 1: COMMAND ANATOMY STYLES
   ============================================ */

.command-input-wrapper {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  margin-bottom: var(--space-md);
}

.command-input {
  flex: 1;
  font-family: var(--font-mono);
  font-size: var(--font-size-md);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border: 2px solid var(--border-default);
  border-radius: var(--radius-md);
  color: var(--text-primary);
}

.command-input:focus {
  outline: none;
  border-color: var(--accent-blue);
}

.try-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  margin-bottom: var(--space-lg);
}

.try-btn {
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  font-family: var(--font-mono);
  background: var(--bg-tertiary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-sm);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.try-btn:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
  border-color: var(--accent-blue);
}

.sentence-breakdown {
  margin-bottom: var(--space-lg);
  padding: var(--space-md);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
}

.sentence-breakdown-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: var(--space-sm);
}

.tokens-container {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  min-height: 60px;
  align-items: flex-start;
}

.token-chip {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--space-sm) var(--space-md);
  background: var(--bg-secondary);
  border: 2px solid var(--border-default);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.token-chip:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.token-chip.selected {
  box-shadow: 0 0 0 2px var(--accent-blue);
}

.token-chip.verb { border-color: var(--accent-blue); }
.token-chip.noun { border-color: var(--accent-green); }
.token-chip.adjective { border-color: var(--accent-yellow); }
.token-chip.preposition { border-color: var(--accent-purple); }
.token-chip.article { border-color: var(--text-muted); opacity: 0.5; text-decoration: line-through; }
.token-chip.direction { border-color: var(--accent-blue); background: rgba(31, 111, 235, 0.1); }
.token-chip.unknown { border-color: var(--accent-red); background: rgba(218, 54, 51, 0.1); }

.token-word {
  font-family: var(--font-mono);
  font-weight: 600;
  font-size: var(--font-size-sm);
}

.token-role {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
  text-transform: uppercase;
  margin-top: var(--space-xs);
}

.assembled-command {
  padding: var(--space-lg);
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
}

.assembled-command-title {
  font-size: var(--font-size-xs);
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: var(--space-md);
}

.command-cards {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: var(--space-md);
  min-height: 80px;
}

.command-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--space-md);
  background: var(--bg-secondary);
  border: 2px solid var(--border-default);
  border-radius: var(--radius-lg);
  min-width: 100px;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.command-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.command-card.selected {
  box-shadow: 0 0 0 2px var(--accent-blue);
}

.command-card.verb-card { border-color: var(--accent-blue); }
.command-card.subject-card { border-color: var(--accent-green); }
.command-card.object-card { border-color: var(--accent-green); }
.command-card.direction-card { border-color: var(--accent-blue); background: rgba(31, 111, 235, 0.1); }
.command-card.text-card { border-color: var(--accent-purple); }
.command-card.error-card { border-color: var(--accent-red); background: rgba(218, 54, 51, 0.1); }
.command-card.ambiguous-card { border-color: var(--accent-yellow); background: rgba(210, 153, 34, 0.1); }

.card-icon {
  font-size: var(--font-size-xl);
  margin-bottom: var(--space-xs);
}

.card-value {
  font-family: var(--font-mono);
  font-weight: 600;
  font-size: var(--font-size-sm);
}

.card-label {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
  text-transform: uppercase;
  margin-top: var(--space-xs);
}

.command-arrow {
  font-size: var(--font-size-lg);
  color: var(--text-muted);
}

.preposition-badge {
  padding: var(--space-xs) var(--space-sm);
  background: var(--accent-purple);
  color: white;
  border-radius: var(--radius-sm);
  font-size: var(--font-size-xs);
  font-weight: 600;
  text-transform: uppercase;
}

.pattern-indicator {
  margin-top: var(--space-md);
  padding: var(--space-sm) var(--space-md);
  background: var(--bg-primary);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-sm);
  display: flex;
  align-items: center;
  gap: var(--space-sm);
}

.pattern-indicator.success { color: var(--accent-green-bright); }
.pattern-indicator.error { color: var(--accent-red-bright); }
.pattern-indicator.ambiguous { color: var(--accent-yellow-bright); }

.color-legend {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-md);
  margin-top: var(--space-md);
  padding: var(--space-sm);
  background: var(--bg-primary);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-xs);
}

.legend-item {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 2px;
}

.legend-color.verb { background: var(--accent-blue); }
.legend-color.noun { background: var(--accent-green); }
.legend-color.adjective { background: var(--accent-yellow); }
.legend-color.preposition { background: var(--accent-purple); }
.legend-color.article { background: var(--text-muted); }

/* ============================================
   EXHIBIT 2: ADVENTURE ROOM STYLES
   ============================================ */

.adventure-container {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--space-lg);
}

@media (min-width: 768px) {
  .adventure-container {
    grid-template-columns: 2fr 1fr;
  }
}

.room-view {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  overflow: hidden;
}

.room-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-md);
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-default);
}

.room-name {
  font-weight: 600;
  font-size: var(--font-size-md);
}

.room-exits {
  display: flex;
  gap: var(--space-xs);
}

.exit-badge {
  padding: var(--space-xs) var(--space-sm);
  background: var(--bg-tertiary);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-xs);
  color: var(--text-secondary);
}

.room-items {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--space-md);
  padding: var(--space-lg);
  min-height: 200px;
}

.room-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--space-md);
  background: var(--bg-secondary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.room-item:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
  border-color: var(--accent-blue);
}

.room-item.pulse {
  animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); box-shadow: 0 0 20px var(--accent-blue); }
}

.room-item.moving {
  animation: float-out 0.4s ease-in forwards;
}

@keyframes float-out {
  to { transform: translateY(-50px); opacity: 0; }
}

.item-icon {
  font-size: var(--font-size-xxl);
  margin-bottom: var(--space-xs);
}

.item-name {
  font-size: var(--font-size-xs);
  color: var(--text-secondary);
  text-align: center;
}

.room-item-placeholder {
  padding: var(--space-md);
  border: 1px dashed var(--border-muted);
  border-radius: var(--radius-md);
  min-height: 80px;
}

.adventure-sidebar {
  display: flex;
  flex-direction: column;
  gap: var(--space-md);
}

.inventory-panel {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-md);
}

.panel-title {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-weight: 600;
  font-size: var(--font-size-sm);
  margin-bottom: var(--space-md);
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-sm);
}

.inventory-slot {
  aspect-ratio: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--bg-secondary);
  border: 1px dashed var(--border-default);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-size: var(--font-size-xs);
  color: var(--text-muted);
}

.inventory-slot.filled {
  border-style: solid;
  border-color: var(--accent-green);
}

.inventory-slot.filled:hover {
  transform: scale(1.05);
  box-shadow: var(--shadow-sm);
}

.inventory-slot .item-icon {
  font-size: var(--font-size-xl);
}

.pronoun-panel {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-md);
}

.pronoun-display {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-sm);
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
  min-height: 50px;
}

.pronoun-display.active {
  border: 2px solid var(--accent-green);
  animation: pronoun-pulse 0.3s ease;
}

@keyframes pronoun-pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(63, 185, 80, 0.4); }
  50% { box-shadow: 0 0 0 8px rgba(63, 185, 80, 0); }
}

.pronoun-icon {
  font-size: var(--font-size-lg);
}

.pronoun-text {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}

.narrative-panel {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-md);
  flex: 1;
}

.narrative-output {
  font-size: var(--font-size-sm);
  line-height: 1.6;
  color: var(--text-secondary);
  min-height: 100px;
  max-height: 200px;
  overflow-y: auto;
}

.narrative-output p {
  margin-bottom: var(--space-sm);
}

.narrative-output .highlight {
  color: var(--text-primary);
}

.disambiguation-choices {
  display: flex;
  gap: var(--space-sm);
  margin-top: var(--space-md);
}

.disambiguation-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--space-md);
  background: var(--bg-secondary);
  border: 2px solid var(--accent-yellow);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.disambiguation-card:hover {
  background: var(--bg-hover);
  transform: translateY(-2px);
}

.adventure-input-area {
  margin-top: var(--space-md);
}

.adventure-try-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  margin-bottom: var(--space-sm);
}

.adventure-input {
  width: 100%;
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
  padding: var(--space-sm) var(--space-md);
}

/* ============================================
   EXHIBIT 3: VOCABULARY WORKSHOP STYLES
   ============================================ */

.vocab-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-lg);
}

@media (max-width: 768px) {
  .vocab-container {
    grid-template-columns: 1fr;
  }
}

.vocab-panel {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-md);
}

.vocab-list {
  max-height: 300px;
  overflow-y: auto;
}

.vocab-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-sm);
  padding: var(--space-sm);
  border-bottom: 1px solid var(--border-muted);
}

.vocab-item:last-child {
  border-bottom: none;
}

.vocab-icon {
  font-size: var(--font-size-md);
  color: var(--accent-blue);
}

.vocab-icon.custom {
  color: var(--accent-purple);
}

.vocab-icon.direction {
  color: var(--text-secondary);
}

.vocab-details {
  flex: 1;
}

.vocab-canonical {
  font-weight: 600;
  font-size: var(--font-size-sm);
}

.vocab-synonyms {
  font-size: var(--font-size-xs);
  color: var(--text-secondary);
}

.vocab-pattern {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
  font-family: var(--font-mono);
  margin-top: var(--space-xs);
}

.vocab-actions {
  display: flex;
  gap: var(--space-xs);
}

.add-vocab-form {
  background: var(--bg-tertiary);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  margin-top: var(--space-lg);
}

.form-title {
  font-weight: 600;
  font-size: var(--font-size-md);
  margin-bottom: var(--space-md);
}

.form-row {
  display: flex;
  align-items: center;
  gap: var(--space-md);
  margin-bottom: var(--space-md);
}

.form-label {
  width: 100px;
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}

.form-input {
  flex: 1;
}

.pattern-preview {
  margin-top: var(--space-md);
  padding: var(--space-md);
  background: var(--bg-primary);
  border-radius: var(--radius-md);
  font-family: var(--font-mono);
  font-size: var(--font-size-sm);
}

.pattern-diagram {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  color: var(--text-secondary);
}

.pattern-circle {
  width: 20px;
  height: 20px;
  border: 2px solid var(--text-muted);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--font-size-xs);
}

.pattern-circle.filled {
  background: var(--accent-green);
  border-color: var(--accent-green);
  color: white;
}

.pattern-line {
  width: 30px;
  height: 2px;
  background: var(--text-muted);
}

.pattern-arrow {
  color: var(--text-muted);
}

.hint-box {
  margin-top: var(--space-lg);
  padding: var(--space-md);
  background: rgba(31, 111, 235, 0.1);
  border: 1px solid var(--accent-blue);
  border-radius: var(--radius-md);
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}

.hint-box span {
  margin-right: var(--space-xs);
}
  </style>
</head>
<body>
  <div class="page">
    <header class="header">
      <h1 class="header-title">@motioneffector/parser</h1>
      <p class="header-description">A natural language command parser for text adventures and interactive fiction.</p>
      <nav class="header-links">
        <a href="https://www.npmjs.com/package/@motioneffector/parser" class="header-link" target="_blank">
          ðŸ“¦ npm
        </a>
        <a href="https://github.com/motioneffector/parser" class="header-link" target="_blank">
          ðŸ’» GitHub
        </a>
        <a href="https://github.com/motioneffector/parser/wiki" class="header-link" target="_blank">
          ðŸ“– Manual
        </a>
      </nav>
    </header>

    <main class="exhibits">
      <!-- Exhibit 1: Command Anatomy -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Command Anatomy</h2>
          <p class="exhibit-description">Watch the parser break down commands into tokens and build structured command objects.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-1">
            <div class="command-input-wrapper">
              <span style="color: var(--text-muted); font-family: var(--font-mono);">&gt;</span>
              <input type="text" class="command-input" id="command-input" placeholder="Type a command..." value="get the brass lamp">
            </div>

            <div class="try-buttons" id="try-buttons">
              <span style="font-size: var(--font-size-xs); color: var(--text-muted); margin-right: var(--space-sm);">TRY:</span>
              <button class="try-btn" data-cmd="get the brass lamp">get the brass lamp</button>
              <button class="try-btn" data-cmd="look">look</button>
              <button class="try-btn" data-cmd="go north">go north</button>
              <button class="try-btn" data-cmd="put key in chest">put key in chest</button>
              <button class="try-btn" data-cmd="exa lamp">exa lamp</button>
              <button class="try-btn" data-cmd="dance">dance</button>
              <button class="try-btn" data-cmd="get ball">get ball</button>
              <button class="try-btn" data-cmd="say hello world">say hello world</button>
            </div>

            <div class="sentence-breakdown">
              <div class="sentence-breakdown-title">Sentence Breakdown</div>
              <div class="tokens-container" id="tokens-container"></div>
            </div>

            <div class="assembled-command">
              <div class="assembled-command-title">Assembled Command</div>
              <div class="command-cards" id="command-cards"></div>
              <div class="pattern-indicator" id="pattern-indicator"></div>
            </div>

            <div class="color-legend">
              <div class="legend-item"><div class="legend-color verb"></div> Verb</div>
              <div class="legend-item"><div class="legend-color noun"></div> Noun</div>
              <div class="legend-item"><div class="legend-color adjective"></div> Adjective</div>
              <div class="legend-item"><div class="legend-color preposition"></div> Preposition</div>
              <div class="legend-item"><div class="legend-color article"></div> Article (stripped)</div>
            </div>
          </div>
        </div>
      </section>

      <!-- Exhibit 2: Adventure Room -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Adventure Room</h2>
          <p class="exhibit-description">Interact with a mini text adventure to see entity resolution, disambiguation, and pronoun tracking in action.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-2">
            <div class="adventure-container">
              <div>
                <div class="room-view">
                  <div class="room-header">
                    <span class="room-name" id="room-name">Living Room</span>
                    <div class="room-exits" id="room-exits">
                      <span class="exit-badge">N</span>
                    </div>
                  </div>
                  <div class="room-items" id="room-items"></div>
                </div>

                <div class="adventure-input-area">
                  <div class="adventure-try-buttons">
                    <span style="font-size: var(--font-size-xs); color: var(--text-muted);">TRY:</span>
                    <button class="try-btn adventure-try" data-cmd="get lamp">get lamp</button>
                    <button class="try-btn adventure-try" data-cmd="examine it">examine it</button>
                    <button class="try-btn adventure-try" data-cmd="get ball">get ball</button>
                    <button class="try-btn adventure-try" data-cmd="drop it">drop it</button>
                    <button class="try-btn adventure-try" data-cmd="north">north</button>
                  </div>
                  <input type="text" class="input adventure-input input-mono" id="adventure-input" placeholder="Enter command...">
                </div>
              </div>

              <div class="adventure-sidebar">
                <div class="inventory-panel">
                  <div class="panel-title">ðŸŽ’ Inventory</div>
                  <div class="inventory-grid" id="inventory-grid">
                    <div class="inventory-slot">empty</div>
                    <div class="inventory-slot">empty</div>
                    <div class="inventory-slot">empty</div>
                    <div class="inventory-slot">empty</div>
                  </div>
                </div>

                <div class="pronoun-panel">
                  <div class="panel-title">"IT" refers to:</div>
                  <div class="pronoun-display" id="pronoun-display">
                    <span class="pronoun-text">(nothing)</span>
                  </div>
                </div>

                <div class="narrative-panel">
                  <div class="panel-title">ðŸ“œ Narrative</div>
                  <div class="narrative-output" id="narrative-output">
                    <p>You are in the <span class="highlight">Living Room</span>.</p>
                    <p>You see a brass lamp, a wooden chest, a red ball, a blue ball, and a rusty key.</p>
                    <p>There is an exit to the <span class="highlight">NORTH</span>.</p>
                    <p style="color: var(--accent-blue);">ðŸ’¡ Click a suggested command above to get started!</p>
                  </div>
                </div>

                <button class="btn btn-secondary" id="reset-room">Reset Room</button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Exhibit 3: Vocabulary Workshop -->
      <section class="exhibit">
        <div class="exhibit-header">
          <h2 class="exhibit-title">Vocabulary Workshop</h2>
          <p class="exhibit-description">Browse the default vocabulary and add custom verbs and directions that work in the demos above.</p>
        </div>
        <div class="exhibit-content">
          <div class="exhibit-interactive" id="exhibit-3">
            <div class="vocab-container">
              <div>
                <div class="vocab-panel">
                  <div class="panel-title">Default Verbs (27)</div>
                  <div class="vocab-list" id="default-verbs"></div>
                </div>
                <div class="vocab-panel mt-md">
                  <div class="panel-title">Default Directions (12)</div>
                  <div class="vocab-list" id="default-directions"></div>
                </div>
              </div>

              <div>
                <div class="vocab-panel">
                  <div class="panel-title">Your Custom Verbs</div>
                  <div class="vocab-list" id="custom-verbs">
                    <div style="padding: var(--space-md); color: var(--text-muted); font-size: var(--font-size-sm);">
                      No custom verbs yet. Add one below!
                    </div>
                  </div>
                </div>
                <div class="vocab-panel mt-md">
                  <div class="panel-title">Your Custom Directions</div>
                  <div class="vocab-list" id="custom-directions">
                    <div style="padding: var(--space-md); color: var(--text-muted); font-size: var(--font-size-sm);">
                      No custom directions yet.
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="add-vocab-form">
              <div class="form-title">Add Custom Verb</div>
              <div class="form-row">
                <label class="form-label">Canonical:</label>
                <input type="text" class="input form-input input-mono" id="verb-canonical" placeholder="CAST" style="text-transform: uppercase;">
              </div>
              <div class="form-row">
                <label class="form-label">Synonyms:</label>
                <input type="text" class="input form-input input-mono" id="verb-synonyms" placeholder="cast, invoke, conjure">
              </div>
              <div class="form-row">
                <label class="form-label">Pattern:</label>
                <select class="input form-input" id="verb-pattern">
                  <option value="none">none - No arguments (look, quit)</option>
                  <option value="subject" selected>subject - One entity (get lamp)</option>
                  <option value="subject_object">subject_object - Two entities (put key in chest)</option>
                  <option value="direction">direction - A direction (go north)</option>
                  <option value="text">text - Free text (say hello)</option>
                </select>
              </div>
              <div class="pattern-preview" id="pattern-preview">
                <div class="pattern-diagram">
                  <span>Pattern:</span>
                  <div class="pattern-circle filled">V</div>
                  <div class="pattern-line"></div>
                  <div class="pattern-circle">S</div>
                </div>
                <div class="mt-sm" style="color: var(--text-muted);">
                  Example: "cast fireball" â†’ CAST [fireball]
                </div>
              </div>
              <button class="btn btn-primary mt-md" id="add-verb-btn">Add to Parser</button>
            </div>

            <div class="hint-box">
              <span>ðŸ’¡</span>
              After adding a verb, try it in the Command Anatomy exhibit above! Type "cast fireball" to see it work.
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="test-runner">
      <div class="test-runner-header">
        <h2 class="test-runner-title">Test Suite</h2>
        <div class="test-runner-actions">
          <button class="btn btn-primary" id="run-tests">Run Tests</button>
          <button class="btn btn-secondary" id="run-fuzz">Run Fuzz Tests</button>
        </div>
      </div>
      <div class="test-runner-content">
        <div class="test-progress">
          <div class="test-progress-bar">
            <div class="test-progress-fill" id="progress-fill"></div>
          </div>
          <div class="test-progress-text" id="progress-text">Ready to run tests</div>
        </div>
        <div class="test-output" id="test-output">
          <div class="test-output-empty">Click "Run Tests" to execute the test suite</div>
        </div>
        <div class="test-summary hidden" id="test-summary">
          <div class="test-summary-item passed">
            <span>âœ“</span>
            <span id="passed-count">0</span> passed
          </div>
          <div class="test-summary-item failed">
            <span>âœ—</span>
            <span id="failed-count">0</span> failed
          </div>
          <div class="test-summary-item skipped">
            <span>â—‹</span>
            <span id="skipped-count">0</span> skipped
          </div>
        </div>
      </div>
    </footer>
  </div>

  <script type="module">
    // ============================================
    // INLINE PARSER IMPLEMENTATION
    // ============================================

    const DEFAULT_VOCABULARY = {
      verbs: [
        { canonical: 'GO', synonyms: ['go', 'walk', 'run'], pattern: 'direction' },
        { canonical: 'ENTER', synonyms: ['enter'], pattern: 'subject' },
        { canonical: 'EXIT', synonyms: ['exit', 'leave'], pattern: 'none' },
        { canonical: 'CLIMB', synonyms: ['climb'], pattern: 'subject' },
        { canonical: 'GET', synonyms: ['get', 'take', 'grab', 'pick'], pattern: 'subject' },
        { canonical: 'DROP', synonyms: ['drop'], pattern: 'subject' },
        { canonical: 'PUT', synonyms: ['put'], pattern: 'subject_object' },
        { canonical: 'GIVE', synonyms: ['give'], pattern: 'subject_object' },
        { canonical: 'THROW', synonyms: ['throw'], pattern: 'subject_object' },
        { canonical: 'OPEN', synonyms: ['open'], pattern: 'subject' },
        { canonical: 'CLOSE', synonyms: ['close'], pattern: 'subject' },
        { canonical: 'LOCK', synonyms: ['lock'], pattern: 'subject' },
        { canonical: 'UNLOCK', synonyms: ['unlock'], pattern: 'subject' },
        { canonical: 'LOOK', synonyms: ['look', 'l'], pattern: 'none' },
        { canonical: 'EXAMINE', synonyms: ['examine', 'x', 'inspect'], pattern: 'subject' },
        { canonical: 'SEARCH', synonyms: ['search'], pattern: 'subject' },
        { canonical: 'READ', synonyms: ['read'], pattern: 'subject' },
        { canonical: 'SAY', synonyms: ['say'], pattern: 'text' },
        { canonical: 'SHOUT', synonyms: ['shout'], pattern: 'text' },
        { canonical: 'TALK', synonyms: ['talk'], pattern: 'subject' },
        { canonical: 'ASK', synonyms: ['ask'], pattern: 'subject_object' },
        { canonical: 'TELL', synonyms: ['tell'], pattern: 'subject_object' },
        { canonical: 'ATTACK', synonyms: ['attack', 'hit', 'strike'], pattern: 'subject' },
        { canonical: 'KILL', synonyms: ['kill'], pattern: 'subject' },
        { canonical: 'FIGHT', synonyms: ['fight'], pattern: 'subject' },
        { canonical: 'INVENTORY', synonyms: ['inventory', 'i', 'inv'], pattern: 'none' },
        { canonical: 'SCORE', synonyms: ['score'], pattern: 'none' },
        { canonical: 'SAVE', synonyms: ['save'], pattern: 'none' },
        { canonical: 'LOAD', synonyms: ['load'], pattern: 'none' },
        { canonical: 'QUIT', synonyms: ['quit'], pattern: 'none' },
        { canonical: 'HELP', synonyms: ['help'], pattern: 'none' },
      ],
      directions: [
        { canonical: 'NORTH', aliases: ['north', 'n'] },
        { canonical: 'SOUTH', aliases: ['south', 's'] },
        { canonical: 'EAST', aliases: ['east', 'e'] },
        { canonical: 'WEST', aliases: ['west', 'w'] },
        { canonical: 'NORTHEAST', aliases: ['northeast', 'ne'] },
        { canonical: 'NORTHWEST', aliases: ['northwest', 'nw'] },
        { canonical: 'SOUTHEAST', aliases: ['southeast', 'se'] },
        { canonical: 'SOUTHWEST', aliases: ['southwest', 'sw'] },
        { canonical: 'UP', aliases: ['up', 'u'] },
        { canonical: 'DOWN', aliases: ['down', 'd'] },
        { canonical: 'IN', aliases: ['in'] },
        { canonical: 'OUT', aliases: ['out'] },
      ],
      prepositions: ['with', 'to', 'at', 'in', 'on', 'from', 'into', 'onto', 'about'],
      articles: ['the', 'a', 'an'],
    }

    function createParser(options) {
      const vocabulary = {
        verbs: [...DEFAULT_VOCABULARY.verbs],
        directions: [...DEFAULT_VOCABULARY.directions],
        prepositions: [...DEFAULT_VOCABULARY.prepositions],
        articles: [...DEFAULT_VOCABULARY.articles],
      }

      let lastReferent = null
      let lastRoom = null

      function tokenize(input) {
        const tokens = []
        const words = input.toLowerCase().trim().split(/\s+/)
        let pos = 0

        for (const word of words) {
          if (!word) continue
          const start = input.toLowerCase().indexOf(word, pos)
          tokens.push({
            type: 'WORD',
            value: word,
            original: input.slice(start, start + word.length),
            start,
            end: start + word.length
          })
          pos = start + word.length
        }

        return tokens
      }

      function findVerb(word) {
        // Exact match first
        for (const verb of vocabulary.verbs) {
          if (verb.synonyms.includes(word)) {
            return verb
          }
        }
        // Partial match
        if (options.partialMatch !== false && word.length >= (options.minPartialLength || 3)) {
          for (const verb of vocabulary.verbs) {
            for (const syn of verb.synonyms) {
              if (syn.startsWith(word)) {
                return { ...verb, partialMatch: syn }
              }
            }
          }
        }
        return null
      }

      function findDirection(word) {
        for (const dir of vocabulary.directions) {
          if (dir.aliases.includes(word)) {
            return dir
          }
        }
        return null
      }

      function parse(input, parseOptions = {}) {
        const scope = parseOptions.scope || {}

        // Check for room change to clear pronoun
        if (scope.room !== undefined && scope.room !== lastRoom) {
          lastReferent = null
          lastRoom = scope.room
        }

        if (!input || !input.trim()) {
          return { type: 'parse_error', message: 'Empty input', position: 0 }
        }

        const tokens = tokenize(input)
        if (tokens.length === 0) {
          return { type: 'parse_error', message: 'Empty input', position: 0 }
        }

        const firstWord = tokens[0].value

        // Check if it's a direction shortcut
        const dirMatch = findDirection(firstWord)
        if (dirMatch) {
          return {
            type: 'command',
            command: {
              verb: 'GO',
              direction: dirMatch.canonical,
              raw: input
            }
          }
        }

        // Find verb
        const verbMatch = findVerb(firstWord)
        if (!verbMatch) {
          return { type: 'unknown_verb', verb: firstWord }
        }

        const command = {
          verb: verbMatch.canonical,
          raw: input
        }

        // Handle patterns
        const remaining = tokens.slice(1).filter(t => !vocabulary.articles.includes(t.value))

        if (verbMatch.pattern === 'none') {
          return { type: 'command', command }
        }

        if (verbMatch.pattern === 'direction') {
          if (remaining.length === 0) {
            return { type: 'parse_error', message: 'Expected direction', position: input.length }
          }
          const dir = findDirection(remaining[0].value)
          if (!dir) {
            return { type: 'parse_error', message: `Expected direction, got "${remaining[0].value}"`, position: remaining[0].start }
          }
          command.direction = dir.canonical
          return { type: 'command', command }
        }

        if (verbMatch.pattern === 'text') {
          const textStart = tokens[0].end
          command.text = input.slice(textStart).trim()
          return { type: 'command', command }
        }

        // subject or subject_object pattern
        if (remaining.length === 0) {
          return { type: 'parse_error', message: `Expected object after ${verbMatch.canonical}`, position: input.length }
        }

        // Find preposition position
        let prepIndex = -1
        let preposition = null
        for (let i = 0; i < remaining.length; i++) {
          if (vocabulary.prepositions.includes(remaining[i].value)) {
            prepIndex = i
            preposition = remaining[i].value
            break
          }
        }

        // Parse subject
        let subjectTokens = prepIndex >= 0 ? remaining.slice(0, prepIndex) : remaining

        // Handle "it" pronoun
        if (subjectTokens.length === 1 && subjectTokens[0].value === 'it') {
          if (!lastReferent) {
            return { type: 'parse_error', message: 'Cannot use "it" without a previous referent', position: subjectTokens[0].start }
          }
          command.subject = { ...lastReferent }
        } else if (subjectTokens.length > 0) {
          const noun = subjectTokens[subjectTokens.length - 1].value
          const adjectives = subjectTokens.slice(0, -1).map(t => t.value)

          const resolved = options.resolver(noun, adjectives, scope)

          if (resolved.length === 0) {
            return { type: 'unknown_noun', noun, position: subjectTokens[subjectTokens.length - 1].start }
          }

          if (resolved.length > 1) {
            return { type: 'ambiguous', candidates: resolved, original: noun, role: 'subject' }
          }

          command.subject = { id: resolved[0].id, noun, adjectives }
          lastReferent = command.subject
        }

        // Parse object if there's a preposition
        if (prepIndex >= 0 && prepIndex < remaining.length - 1) {
          command.preposition = preposition
          const objectTokens = remaining.slice(prepIndex + 1)

          if (objectTokens.length === 1 && objectTokens[0].value === 'it') {
            if (!lastReferent) {
              return { type: 'parse_error', message: 'Cannot use "it" without a previous referent', position: objectTokens[0].start }
            }
            command.object = { ...lastReferent }
          } else {
            const noun = objectTokens[objectTokens.length - 1].value
            const adjectives = objectTokens.slice(0, -1).map(t => t.value)

            const resolved = options.resolver(noun, adjectives, scope)

            if (resolved.length === 0) {
              return { type: 'unknown_noun', noun, position: objectTokens[objectTokens.length - 1].start }
            }

            if (resolved.length > 1) {
              return { type: 'ambiguous', candidates: resolved, original: noun, role: 'object' }
            }

            command.object = { id: resolved[0].id, noun, adjectives }
          }
        } else if (verbMatch.pattern === 'subject_object' && prepIndex < 0) {
          return { type: 'parse_error', message: 'Expected preposition and target', position: input.length }
        }

        return { type: 'command', command }
      }

      return {
        parse,
        addVerb(def) {
          vocabulary.verbs.push(def)
        },
        addDirection(def) {
          vocabulary.directions.push(def)
        },
        clearPronoun() {
          lastReferent = null
        },
        getVocabulary() {
          return vocabulary
        }
      }
    }

    // ============================================
    // GAME STATE
    // ============================================

    const gameItems = {
      'lamp': { id: 'lamp-1', name: 'brass lamp', icon: 'ðŸ’¡', adjectives: ['brass'], description: 'A well-polished brass lamp.' },
      'chest': { id: 'chest-1', name: 'wooden chest', icon: 'ðŸ“¦', adjectives: ['wooden'], description: 'A sturdy wooden chest.' },
      'ball-red': { id: 'ball-red', name: 'red ball', icon: 'ðŸ”´', adjectives: ['red'], description: 'A bright red ball.' },
      'ball-blue': { id: 'ball-blue', name: 'blue ball', icon: 'ðŸ”µ', adjectives: ['blue'], description: 'A shiny blue ball.' },
      'key': { id: 'key-1', name: 'rusty key', icon: 'ðŸ”‘', adjectives: ['rusty'], description: 'An old rusty key.' },
      'stove': { id: 'stove-1', name: 'stove', icon: 'â™¨ï¸', adjectives: [], description: 'A kitchen stove.' },
      'knife': { id: 'knife-1', name: 'sharp knife', icon: 'ðŸ”ª', adjectives: ['sharp'], description: 'A sharp kitchen knife.' },
    }

    const rooms = {
      'living-room': {
        name: 'Living Room',
        items: ['lamp', 'chest', 'ball-red', 'ball-blue', 'key'],
        exits: { north: 'kitchen' },
        description: 'A cozy living room with comfortable furniture.'
      },
      'kitchen': {
        name: 'Kitchen',
        items: ['stove', 'knife'],
        exits: { south: 'living-room' },
        description: 'A small but functional kitchen.'
      }
    }

    let currentRoom = 'living-room'
    let inventory = []
    let pronounRef = null

    // ============================================
    // SHARED PARSER INSTANCE
    // ============================================

    const sharedParser = createParser({
      resolver: (noun, adjectives, scope) => {
        const room = scope?.room || currentRoom
        const roomData = rooms[room]
        const inv = scope?.inventory || inventory

        // Search in room and inventory
        const searchItems = [...(roomData?.items || []), ...inv]
        const matches = []

        for (const itemKey of searchItems) {
          const item = gameItems[itemKey]
          if (!item) continue

          // Match by noun
          const itemNouns = [item.name.split(' ').pop(), ...item.name.split(' ')]
          if (!itemNouns.some(n => n === noun || n.startsWith(noun))) continue

          // Match adjectives if provided
          if (adjectives.length > 0) {
            const hasAllAdj = adjectives.every(adj =>
              item.adjectives.includes(adj) || item.name.includes(adj)
            )
            if (!hasAllAdj) continue
          }

          matches.push({ id: item.id, name: item.name, icon: item.icon, key: itemKey })
        }

        // Special case: "ball" without adjective returns both balls
        if (noun === 'ball' && adjectives.length === 0) {
          const balls = []
          for (const key of searchItems) {
            if (key === 'ball-red' || key === 'ball-blue') {
              const item = gameItems[key]
              balls.push({ id: item.id, name: item.name, icon: item.icon, key })
            }
          }
          if (balls.length > 1) return balls
        }

        return matches
      },
      partialMatch: true,
      minPartialLength: 3
    })

    // Add pre-loaded custom verbs
    sharedParser.addVerb({ canonical: 'CAST', synonyms: ['cast', 'invoke'], pattern: 'subject' })
    sharedParser.addVerb({ canonical: 'ENCHANT', synonyms: ['enchant', 'imbue'], pattern: 'subject_object' })
    sharedParser.addDirection({ canonical: 'PORTAL', aliases: ['portal', 'p'] })

    // ============================================
    // EXHIBIT 1: COMMAND ANATOMY
    // ============================================

    function analyzeCommand(input) {
      const result = sharedParser.parse(input, {
        scope: { room: currentRoom, inventory }
      })

      // Tokenize for display
      const words = input.toLowerCase().trim().split(/\s+/)
      const tokens = []
      const vocab = sharedParser.getVocabulary()

      // Identify each word's role
      let foundVerb = false
      let foundPrep = false
      let inObject = false

      for (let i = 0; i < words.length; i++) {
        const word = words[i]
        let role = 'unknown'

        if (!foundVerb) {
          // Check if it's a verb
          const isVerb = vocab.verbs.some(v =>
            v.synonyms.includes(word) ||
            v.synonyms.some(s => s.startsWith(word) && word.length >= 3)
          )
          const isDir = vocab.directions.some(d => d.aliases.includes(word))

          if (isVerb) {
            role = 'verb'
            foundVerb = true
          } else if (isDir) {
            role = 'direction'
            foundVerb = true
          } else {
            role = 'unknown'
          }
        } else if (vocab.articles.includes(word)) {
          role = 'article'
        } else if (vocab.prepositions.includes(word)) {
          role = 'preposition'
          foundPrep = true
          inObject = true
        } else {
          // Could be adjective or noun
          // Last word before preposition or end is noun, others are adjectives
          const remainingWords = words.slice(i)
          const nextPrepIdx = remainingWords.findIndex(w => vocab.prepositions.includes(w))
          const wordsBeforePrep = nextPrepIdx >= 0 ? remainingWords.slice(0, nextPrepIdx) : remainingWords
          const nonArticles = wordsBeforePrep.filter(w => !vocab.articles.includes(w))

          if (nonArticles.length === 1 || word === nonArticles[nonArticles.length - 1]) {
            role = 'noun'
          } else {
            role = 'adjective'
          }
        }

        tokens.push({ word, role })
      }

      return { result, tokens }
    }

    function renderTokens(tokens) {
      const container = document.getElementById('tokens-container')
      container.innerHTML = ''

      tokens.forEach((token, i) => {
        const chip = document.createElement('div')
        chip.className = `token-chip ${token.role}`
        chip.innerHTML = `
          <span class="token-word">${token.word}</span>
          <span class="token-role">${token.role}</span>
        `
        chip.dataset.index = i
        container.appendChild(chip)
      })
    }

    function renderCommand(result) {
      const container = document.getElementById('command-cards')
      const indicator = document.getElementById('pattern-indicator')
      container.innerHTML = ''

      if (result.type === 'command') {
        const cmd = result.command

        // Verb card
        const verbCard = document.createElement('div')
        verbCard.className = 'command-card verb-card'
        verbCard.innerHTML = `
          <span class="card-icon">âš¡</span>
          <span class="card-value">${cmd.verb}</span>
          <span class="card-label">verb</span>
        `
        container.appendChild(verbCard)

        // Direction
        if (cmd.direction) {
          container.appendChild(createArrow())
          const dirCard = document.createElement('div')
          dirCard.className = 'command-card direction-card'
          dirCard.innerHTML = `
            <span class="card-icon">ðŸ§­</span>
            <span class="card-value">${cmd.direction}</span>
            <span class="card-label">direction</span>
          `
          container.appendChild(dirCard)
        }

        // Subject
        if (cmd.subject) {
          container.appendChild(createArrow())
          const item = Object.values(gameItems).find(i => i.id === cmd.subject.id)
          const subjectCard = document.createElement('div')
          subjectCard.className = 'command-card subject-card'
          subjectCard.innerHTML = `
            <span class="card-icon">${item?.icon || 'ðŸ“¦'}</span>
            <span class="card-value">${cmd.subject.adjectives?.length ? cmd.subject.adjectives.join(' ') + ' ' : ''}${cmd.subject.noun}</span>
            <span class="card-label">subject</span>
          `
          container.appendChild(subjectCard)
        }

        // Preposition + Object
        if (cmd.preposition && cmd.object) {
          const prepBadge = document.createElement('span')
          prepBadge.className = 'preposition-badge'
          prepBadge.textContent = cmd.preposition
          container.appendChild(prepBadge)

          container.appendChild(createArrow())

          const item = Object.values(gameItems).find(i => i.id === cmd.object.id)
          const objectCard = document.createElement('div')
          objectCard.className = 'command-card object-card'
          objectCard.innerHTML = `
            <span class="card-icon">${item?.icon || 'ðŸ“¦'}</span>
            <span class="card-value">${cmd.object.adjectives?.length ? cmd.object.adjectives.join(' ') + ' ' : ''}${cmd.object.noun}</span>
            <span class="card-label">object</span>
          `
          container.appendChild(objectCard)
        }

        // Text
        if (cmd.text) {
          container.appendChild(createArrow())
          const textCard = document.createElement('div')
          textCard.className = 'command-card text-card'
          textCard.innerHTML = `
            <span class="card-icon">ðŸ’¬</span>
            <span class="card-value">"${cmd.text}"</span>
            <span class="card-label">text</span>
          `
          container.appendChild(textCard)
        }

        indicator.className = 'pattern-indicator success'
        indicator.innerHTML = `<span>âœ“</span> Parse successful`

      } else if (result.type === 'unknown_verb') {
        const errorCard = document.createElement('div')
        errorCard.className = 'command-card error-card'
        errorCard.innerHTML = `
          <span class="card-icon">âŒ</span>
          <span class="card-value">${result.verb}</span>
          <span class="card-label">unknown verb</span>
        `
        container.appendChild(errorCard)

        indicator.className = 'pattern-indicator error'
        indicator.innerHTML = `<span>âœ—</span> Unknown verb: "${result.verb}"`

      } else if (result.type === 'unknown_noun') {
        const verbCard = document.createElement('div')
        verbCard.className = 'command-card verb-card'
        verbCard.innerHTML = `
          <span class="card-icon">âš¡</span>
          <span class="card-value">?</span>
          <span class="card-label">verb</span>
        `
        container.appendChild(verbCard)
        container.appendChild(createArrow())

        const errorCard = document.createElement('div')
        errorCard.className = 'command-card error-card'
        errorCard.innerHTML = `
          <span class="card-icon">âŒ</span>
          <span class="card-value">${result.noun}</span>
          <span class="card-label">unknown noun</span>
        `
        container.appendChild(errorCard)

        indicator.className = 'pattern-indicator error'
        indicator.innerHTML = `<span>âœ—</span> Unknown noun: "${result.noun}"`

      } else if (result.type === 'ambiguous') {
        const verbCard = document.createElement('div')
        verbCard.className = 'command-card verb-card'
        verbCard.innerHTML = `
          <span class="card-icon">âš¡</span>
          <span class="card-value">?</span>
          <span class="card-label">verb</span>
        `
        container.appendChild(verbCard)
        container.appendChild(createArrow())

        const ambigCard = document.createElement('div')
        ambigCard.className = 'command-card ambiguous-card'
        ambigCard.innerHTML = `
          <span class="card-icon">âš ï¸</span>
          <span class="card-value">${result.candidates.map(c => c.name || c.id).join(' or ')}</span>
          <span class="card-label">ambiguous ${result.role}</span>
        `
        container.appendChild(ambigCard)

        indicator.className = 'pattern-indicator ambiguous'
        indicator.innerHTML = `<span>âš ï¸</span> Ambiguous: Which "${result.original}"?`

      } else if (result.type === 'parse_error') {
        const errorCard = document.createElement('div')
        errorCard.className = 'command-card error-card'
        errorCard.innerHTML = `
          <span class="card-icon">âŒ</span>
          <span class="card-value">${result.message}</span>
          <span class="card-label">parse error</span>
        `
        container.appendChild(errorCard)

        indicator.className = 'pattern-indicator error'
        indicator.innerHTML = `<span>âœ—</span> ${result.message}`
      }
    }

    function createArrow() {
      const arrow = document.createElement('span')
      arrow.className = 'command-arrow'
      arrow.textContent = 'â†’'
      return arrow
    }

    function updateExhibit1() {
      const input = document.getElementById('command-input').value
      const { result, tokens } = analyzeCommand(input)
      renderTokens(tokens)
      renderCommand(result)
    }

    // Event listeners for Exhibit 1
    document.getElementById('command-input').addEventListener('input', updateExhibit1)
    document.getElementById('command-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') updateExhibit1()
    })

    document.getElementById('try-buttons').addEventListener('click', (e) => {
      if (e.target.classList.contains('try-btn')) {
        document.getElementById('command-input').value = e.target.dataset.cmd
        updateExhibit1()
      }
    })

    // Initial render
    updateExhibit1()

    // ============================================
    // EXHIBIT 2: ADVENTURE ROOM
    // ============================================

    let disambiguationPending = null

    function renderRoom() {
      const roomData = rooms[currentRoom]
      document.getElementById('room-name').textContent = roomData.name

      // Render exits
      const exitsContainer = document.getElementById('room-exits')
      exitsContainer.innerHTML = ''
      for (const [dir, _] of Object.entries(roomData.exits)) {
        const badge = document.createElement('span')
        badge.className = 'exit-badge'
        badge.textContent = dir[0].toUpperCase()
        exitsContainer.appendChild(badge)
      }

      // Render items
      const itemsContainer = document.getElementById('room-items')
      itemsContainer.innerHTML = ''

      for (const itemKey of roomData.items) {
        const item = gameItems[itemKey]
        if (!item) continue

        const itemEl = document.createElement('div')
        itemEl.className = 'room-item'
        itemEl.dataset.key = itemKey
        itemEl.innerHTML = `
          <span class="item-icon">${item.icon}</span>
          <span class="item-name">${item.name}</span>
        `
        itemEl.addEventListener('click', () => {
          addNarrative(`The ${item.name}: ${item.description}`)
        })
        itemsContainer.appendChild(itemEl)
      }

      // Fill empty slots
      while (itemsContainer.children.length < 6) {
        const placeholder = document.createElement('div')
        placeholder.className = 'room-item-placeholder'
        itemsContainer.appendChild(placeholder)
      }
    }

    function renderInventory() {
      const grid = document.getElementById('inventory-grid')
      grid.innerHTML = ''

      for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div')
        slot.className = 'inventory-slot'

        if (inventory[i]) {
          const item = gameItems[inventory[i]]
          slot.classList.add('filled')
          slot.innerHTML = `
            <span class="item-icon">${item.icon}</span>
            <span class="item-name">${item.name}</span>
          `
          slot.dataset.key = inventory[i]
          slot.addEventListener('click', () => {
            addNarrative(`The ${item.name}: ${item.description}`)
          })
        } else {
          slot.textContent = 'empty'
        }

        grid.appendChild(slot)
      }
    }

    function updatePronoun(item) {
      pronounRef = item
      const display = document.getElementById('pronoun-display')

      if (item) {
        const itemData = gameItems[item.key || item]
        display.innerHTML = `
          <span class="pronoun-icon">${itemData?.icon || 'ðŸ“¦'}</span>
          <span class="pronoun-text">${itemData?.name || item}</span>
        `
        display.classList.add('active')
        setTimeout(() => display.classList.remove('active'), 300)
      } else {
        display.innerHTML = '<span class="pronoun-text">(nothing)</span>'
      }
    }

    function addNarrative(text) {
      const output = document.getElementById('narrative-output')
      const p = document.createElement('p')
      p.innerHTML = text
      output.appendChild(p)
      output.scrollTop = output.scrollHeight
    }

    function clearNarrative() {
      document.getElementById('narrative-output').innerHTML = ''
    }

    function executeAdventureCommand(input) {
      // Handle disambiguation response
      if (disambiguationPending) {
        const choice = input.trim()
        let selected = null

        if (choice === '1' || choice === '2') {
          selected = disambiguationPending.candidates[parseInt(choice) - 1]
        } else {
          // Try to match by name
          selected = disambiguationPending.candidates.find(c =>
            c.name?.toLowerCase().includes(choice.toLowerCase())
          )
        }

        if (selected) {
          // Execute the pending command with the selected entity
          const itemKey = selected.key
          if (disambiguationPending.verb === 'GET') {
            const roomData = rooms[currentRoom]
            const idx = roomData.items.indexOf(itemKey)
            if (idx >= 0) {
              roomData.items.splice(idx, 1)
              inventory.push(itemKey)
              addNarrative(`You take the ${selected.name}.`)
              updatePronoun({ key: itemKey })
            }
          }
          renderRoom()
          renderInventory()
        } else {
          addNarrative('Please choose 1 or 2, or type a more specific name.')
          return
        }

        disambiguationPending = null
        hideDisambiguation()
        return
      }

      const result = sharedParser.parse(input, {
        scope: { room: currentRoom, inventory }
      })

      if (result.type === 'command') {
        const cmd = result.command

        switch (cmd.verb) {
          case 'LOOK':
            const roomData = rooms[currentRoom]
            addNarrative(`You are in the <span class="highlight">${roomData.name}</span>.`)
            addNarrative(roomData.description)
            if (roomData.items.length > 0) {
              const itemNames = roomData.items.map(k => gameItems[k]?.name).filter(Boolean)
              addNarrative(`You see: ${itemNames.join(', ')}.`)
            }
            break

          case 'GET':
            if (cmd.subject) {
              const itemKey = findItemKey(cmd.subject.id)
              const roomData = rooms[currentRoom]
              const idx = roomData.items.indexOf(itemKey)

              if (idx >= 0) {
                // Animate
                const itemEl = document.querySelector(`.room-item[data-key="${itemKey}"]`)
                if (itemEl) {
                  itemEl.classList.add('moving')
                  setTimeout(() => {
                    roomData.items.splice(idx, 1)
                    inventory.push(itemKey)
                    renderRoom()
                    renderInventory()
                  }, 400)
                } else {
                  roomData.items.splice(idx, 1)
                  inventory.push(itemKey)
                  renderRoom()
                  renderInventory()
                }
                addNarrative(`You take the ${gameItems[itemKey]?.name || cmd.subject.noun}.`)
                updatePronoun({ key: itemKey })
              } else {
                addNarrative(`You don't see that here.`)
              }
            }
            break

          case 'DROP':
            if (cmd.subject) {
              const itemKey = findItemKey(cmd.subject.id)
              const idx = inventory.indexOf(itemKey)

              if (idx >= 0) {
                inventory.splice(idx, 1)
                rooms[currentRoom].items.push(itemKey)
                addNarrative(`You drop the ${gameItems[itemKey]?.name || cmd.subject.noun}.`)
                renderRoom()
                renderInventory()
              } else {
                addNarrative(`You're not carrying that.`)
              }
            }
            break

          case 'EXAMINE':
            if (cmd.subject) {
              const itemKey = findItemKey(cmd.subject.id)
              const item = gameItems[itemKey]
              if (item) {
                // Pulse the item
                const itemEl = document.querySelector(`.room-item[data-key="${itemKey}"]`)
                if (itemEl) {
                  itemEl.classList.add('pulse')
                  setTimeout(() => itemEl.classList.remove('pulse'), 500)
                }
                addNarrative(`The ${item.name}: ${item.description}`)
                updatePronoun({ key: itemKey })
              }
            }
            break

          case 'INVENTORY':
            if (inventory.length === 0) {
              addNarrative(`You're not carrying anything.`)
            } else {
              const itemNames = inventory.map(k => gameItems[k]?.name).filter(Boolean)
              addNarrative(`You are carrying: ${itemNames.join(', ')}.`)
            }
            break

          case 'GO':
            const dir = cmd.direction?.toLowerCase()
            const exits = rooms[currentRoom].exits
            const nextRoom = exits[dir]

            if (nextRoom) {
              currentRoom = nextRoom
              sharedParser.clearPronoun()
              updatePronoun(null)

              const newRoomData = rooms[currentRoom]
              clearNarrative()
              addNarrative(`You go ${dir}.`)
              addNarrative(`You are now in the <span class="highlight">${newRoomData.name}</span>.`)
              addNarrative(newRoomData.description)
              if (newRoomData.items.length > 0) {
                const itemNames = newRoomData.items.map(k => gameItems[k]?.name).filter(Boolean)
                addNarrative(`You see: ${itemNames.join(', ')}.`)
              }
              renderRoom()
            } else {
              addNarrative(`You can't go that way.`)
            }
            break

          default:
            addNarrative(`You ${cmd.verb.toLowerCase()}.`)
        }

      } else if (result.type === 'unknown_verb') {
        addNarrative(`I don't understand "${result.verb}".`)

      } else if (result.type === 'unknown_noun') {
        addNarrative(`I don't see any "${result.noun}" here.`)

      } else if (result.type === 'ambiguous') {
        disambiguationPending = { ...result, verb: input.split(' ')[0].toUpperCase() }
        showDisambiguation(result.candidates)
        addNarrative(`Which ${result.original} do you mean?`)

      } else if (result.type === 'parse_error') {
        addNarrative(result.message)
      }
    }

    function findItemKey(id) {
      for (const [key, item] of Object.entries(gameItems)) {
        if (item.id === id) return key
      }
      return null
    }

    function showDisambiguation(candidates) {
      const output = document.getElementById('narrative-output')
      const choicesDiv = document.createElement('div')
      choicesDiv.className = 'disambiguation-choices'
      choicesDiv.id = 'disambiguation-choices'

      candidates.forEach((c, i) => {
        const card = document.createElement('div')
        card.className = 'disambiguation-card'
        card.innerHTML = `
          <span class="item-icon">${c.icon || 'ðŸ“¦'}</span>
          <span>${c.name}</span>
          <span class="tag">[${i + 1}]</span>
        `
        card.addEventListener('click', () => {
          executeAdventureCommand((i + 1).toString())
        })
        choicesDiv.appendChild(card)
      })

      output.appendChild(choicesDiv)
    }

    function hideDisambiguation() {
      const choices = document.getElementById('disambiguation-choices')
      if (choices) choices.remove()
    }

    function resetAdventure() {
      currentRoom = 'living-room'
      inventory = []
      pronounRef = null
      disambiguationPending = null
      sharedParser.clearPronoun()

      // Reset room items
      rooms['living-room'].items = ['lamp', 'chest', 'ball-red', 'ball-blue', 'key']
      rooms['kitchen'].items = ['stove', 'knife']

      renderRoom()
      renderInventory()
      updatePronoun(null)
      clearNarrative()
      addNarrative(`You are in the <span class="highlight">Living Room</span>.`)
      addNarrative(`You see a brass lamp, a wooden chest, a red ball, a blue ball, and a rusty key.`)
      addNarrative(`There is an exit to the <span class="highlight">NORTH</span>.`)
      addNarrative(`<span style="color: var(--accent-blue);">ðŸ’¡ Click a suggested command above to get started!</span>`)
    }

    // Event listeners for Exhibit 2
    document.getElementById('adventure-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const input = e.target.value.trim()
        if (input) {
          executeAdventureCommand(input)
          e.target.value = ''
        }
      }
    })

    document.querySelectorAll('.adventure-try').forEach(btn => {
      btn.addEventListener('click', () => {
        executeAdventureCommand(btn.dataset.cmd)
      })
    })

    document.getElementById('reset-room').addEventListener('click', resetAdventure)

    // Initial render
    renderRoom()
    renderInventory()

    // ============================================
    // EXHIBIT 3: VOCABULARY WORKSHOP
    // ============================================

    const customVerbs = []
    const customDirections = []

    function renderDefaultVocab() {
      const vocab = sharedParser.getVocabulary()

      // Render default verbs
      const verbsList = document.getElementById('default-verbs')
      verbsList.innerHTML = ''

      for (const verb of DEFAULT_VOCABULARY.verbs) {
        const item = document.createElement('div')
        item.className = 'vocab-item'
        item.innerHTML = `
          <span class="vocab-icon">ðŸ”·</span>
          <div class="vocab-details">
            <div class="vocab-canonical">${verb.canonical}</div>
            <div class="vocab-synonyms">${verb.synonyms.join(', ')}</div>
            <div class="vocab-pattern">pattern: ${verb.pattern}</div>
          </div>
        `
        verbsList.appendChild(item)
      }

      // Render default directions
      const dirsList = document.getElementById('default-directions')
      dirsList.innerHTML = ''

      for (const dir of DEFAULT_VOCABULARY.directions) {
        const item = document.createElement('div')
        item.className = 'vocab-item'
        item.innerHTML = `
          <span class="vocab-icon direction">â†—</span>
          <div class="vocab-details">
            <div class="vocab-canonical">${dir.canonical}</div>
            <div class="vocab-synonyms">${dir.aliases.join(', ')}</div>
          </div>
        `
        dirsList.appendChild(item)
      }
    }

    function renderCustomVocab() {
      const verbsList = document.getElementById('custom-verbs')
      const dirsList = document.getElementById('custom-directions')

      if (customVerbs.length === 0) {
        verbsList.innerHTML = `<div style="padding: var(--space-md); color: var(--text-muted); font-size: var(--font-size-sm);">
          No custom verbs yet. Add one below!
        </div>`
      } else {
        verbsList.innerHTML = ''
        customVerbs.forEach((verb, i) => {
          const item = document.createElement('div')
          item.className = 'vocab-item'
          item.innerHTML = `
            <span class="vocab-icon custom">ðŸŸ£</span>
            <div class="vocab-details">
              <div class="vocab-canonical">${verb.canonical}</div>
              <div class="vocab-synonyms">${verb.synonyms.join(', ')}</div>
              <div class="vocab-pattern">pattern: ${verb.pattern}</div>
            </div>
            <div class="vocab-actions">
              <button class="btn btn-small btn-danger" data-index="${i}">ðŸ—‘ï¸</button>
            </div>
          `
          item.querySelector('.btn-danger').addEventListener('click', () => {
            customVerbs.splice(i, 1)
            renderCustomVocab()
          })
          verbsList.appendChild(item)
        })
      }

      if (customDirections.length === 0) {
        dirsList.innerHTML = `<div style="padding: var(--space-md); color: var(--text-muted); font-size: var(--font-size-sm);">
          No custom directions yet.
        </div>`
      } else {
        dirsList.innerHTML = ''
        customDirections.forEach((dir, i) => {
          const item = document.createElement('div')
          item.className = 'vocab-item'
          item.innerHTML = `
            <span class="vocab-icon custom">â­</span>
            <div class="vocab-details">
              <div class="vocab-canonical">${dir.canonical}</div>
              <div class="vocab-synonyms">${dir.aliases.join(', ')}</div>
            </div>
            <div class="vocab-actions">
              <button class="btn btn-small btn-danger" data-index="${i}">ðŸ—‘ï¸</button>
            </div>
          `
          item.querySelector('.btn-danger').addEventListener('click', () => {
            customDirections.splice(i, 1)
            renderCustomVocab()
          })
          dirsList.appendChild(item)
        })
      }
    }

    function updatePatternPreview() {
      const pattern = document.getElementById('verb-pattern').value
      const canonical = document.getElementById('verb-canonical').value.toUpperCase() || 'VERB'
      const preview = document.getElementById('pattern-preview')

      let diagram = ''
      let example = ''

      switch (pattern) {
        case 'none':
          diagram = `<div class="pattern-circle filled">V</div>`
          example = `"${canonical.toLowerCase()}" â†’ ${canonical}`
          break
        case 'subject':
          diagram = `<div class="pattern-circle filled">V</div>
                     <div class="pattern-line"></div>
                     <div class="pattern-circle">S</div>`
          example = `"${canonical.toLowerCase()} thing" â†’ ${canonical} [thing]`
          break
        case 'subject_object':
          diagram = `<div class="pattern-circle filled">V</div>
                     <div class="pattern-line"></div>
                     <div class="pattern-circle">S</div>
                     <span class="pattern-arrow">â†’</span>
                     <div class="pattern-circle">O</div>`
          example = `"${canonical.toLowerCase()} X in Y" â†’ ${canonical} [X] in [Y]`
          break
        case 'direction':
          diagram = `<div class="pattern-circle filled">V</div>
                     <div class="pattern-line"></div>
                     <div class="pattern-circle">D</div>`
          example = `"${canonical.toLowerCase()} north" â†’ ${canonical} NORTH`
          break
        case 'text':
          diagram = `<div class="pattern-circle filled">V</div>
                     <div class="pattern-line"></div>
                     <span style="color: var(--accent-purple);">...</span>`
          example = `"${canonical.toLowerCase()} hello world" â†’ ${canonical} "hello world"`
          break
      }

      preview.innerHTML = `
        <div class="pattern-diagram">${diagram}</div>
        <div class="mt-sm" style="color: var(--text-muted);">Example: ${example}</div>
      `
    }

    // Event listeners for Exhibit 3
    document.getElementById('verb-pattern').addEventListener('change', updatePatternPreview)
    document.getElementById('verb-canonical').addEventListener('input', updatePatternPreview)

    document.getElementById('add-verb-btn').addEventListener('click', () => {
      const canonical = document.getElementById('verb-canonical').value.toUpperCase().trim()
      const synonymsStr = document.getElementById('verb-synonyms').value.trim()
      const pattern = document.getElementById('verb-pattern').value

      if (!canonical || !synonymsStr) {
        alert('Please fill in both canonical name and synonyms')
        return
      }

      const synonyms = synonymsStr.split(',').map(s => s.trim().toLowerCase()).filter(Boolean)

      const newVerb = { canonical, synonyms, pattern }
      customVerbs.push(newVerb)
      sharedParser.addVerb(newVerb)

      // Clear form
      document.getElementById('verb-canonical').value = ''
      document.getElementById('verb-synonyms').value = ''

      renderCustomVocab()

      // Update exhibit 1 if it's showing something
      updateExhibit1()
    })

    // Initial render
    renderDefaultVocab()
    renderCustomVocab()
    updatePatternPreview()

    // ============================================
    // TEST RUNNER
    // ============================================

    const testRunner = {
      tests: [],
      results: [],
      running: false,

      register(name, fn) {
        this.tests.push({ name, fn })
      },

      async run() {
        if (this.running) return
        this.running = true
        this.results = []

        const output = document.getElementById('test-output')
        const progressFill = document.getElementById('progress-fill')
        const progressText = document.getElementById('progress-text')
        const summary = document.getElementById('test-summary')
        const passedCount = document.getElementById('passed-count')
        const failedCount = document.getElementById('failed-count')
        const skippedCount = document.getElementById('skipped-count')
        const runBtn = document.getElementById('run-tests')

        runBtn.disabled = true
        output.innerHTML = ''
        summary.classList.add('hidden')
        progressFill.style.width = '0%'
        progressFill.className = 'test-progress-fill'

        let passed = 0
        let failed = 0

        for (let i = 0; i < this.tests.length; i++) {
          const test = this.tests[i]
          const progress = ((i + 1) / this.tests.length) * 100

          progressFill.style.width = `${progress}%`
          progressText.textContent = `Running: ${test.name}`

          try {
            await test.fn()
            passed++
            this.results.push({ name: test.name, passed: true })
            output.innerHTML += `
              <div class="test-item">
                <span class="test-icon pass">âœ“</span>
                <span class="test-name">${escapeHtml(test.name)}</span>
              </div>
            `
          } catch (e) {
            failed++
            this.results.push({ name: test.name, passed: false, error: e.message })
            output.innerHTML += `
              <div class="test-item">
                <span class="test-icon fail">âœ—</span>
                <div>
                  <div class="test-name">${escapeHtml(test.name)}</div>
                  <div class="test-error">${escapeHtml(e.message)}</div>
                </div>
              </div>
            `
          }

          output.scrollTop = output.scrollHeight
          await new Promise(r => setTimeout(r, 20))
        }

        progressFill.classList.add(failed === 0 ? 'success' : 'failure')
        progressText.textContent = `Complete: ${passed}/${this.tests.length} passed`

        passedCount.textContent = passed
        failedCount.textContent = failed
        skippedCount.textContent = 0
        summary.classList.remove('hidden')

        runBtn.disabled = false
        this.running = false
      }
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
    }

    function assert(condition, message) {
      if (!condition) throw new Error(message || 'Assertion failed')
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, got ${actual}`)
      }
    }

    // Register tests
    testRunner.register('creates parser with resolver', () => {
      const parser = createParser({ resolver: () => [] })
      assert(parser, 'Parser should be created')
      assert(typeof parser.parse === 'function', 'Parser should have parse method')
    })

    testRunner.register('parses simple verb command', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('look')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'LOOK')
    })

    testRunner.register('parses verb with subject', () => {
      const parser = createParser({ resolver: () => [{ id: 'item-1' }] })
      const result = parser.parse('get lamp')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'GET')
      assertEqual(result.command.subject.noun, 'lamp')
    })

    testRunner.register('strips articles from input', () => {
      const parser = createParser({ resolver: () => [{ id: 'item-1' }] })
      const result = parser.parse('get the lamp')
      assertEqual(result.type, 'command')
      assertEqual(result.command.subject.noun, 'lamp')
    })

    testRunner.register('parses direction shortcut', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('north')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'GO')
      assertEqual(result.command.direction, 'NORTH')
    })

    testRunner.register('parses direction alias', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('n')
      assertEqual(result.type, 'command')
      assertEqual(result.command.direction, 'NORTH')
    })

    testRunner.register('parses go with direction', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('go north')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'GO')
      assertEqual(result.command.direction, 'NORTH')
    })

    testRunner.register('parses subject_object pattern', () => {
      const parser = createParser({ resolver: (noun) => [{ id: noun }] })
      const result = parser.parse('put key in chest')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'PUT')
      assertEqual(result.command.subject.noun, 'key')
      assertEqual(result.command.preposition, 'in')
      assertEqual(result.command.object.noun, 'chest')
    })

    testRunner.register('parses text pattern', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('say hello world')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'SAY')
      assertEqual(result.command.text, 'hello world')
    })

    testRunner.register('returns unknown_verb for unrecognized verb', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('dance')
      assertEqual(result.type, 'unknown_verb')
      assertEqual(result.verb, 'dance')
    })

    testRunner.register('returns unknown_noun when resolver returns empty', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('get unicorn')
      assertEqual(result.type, 'unknown_noun')
      assertEqual(result.noun, 'unicorn')
    })

    testRunner.register('returns ambiguous when resolver returns multiple', () => {
      const parser = createParser({ resolver: () => [{ id: '1' }, { id: '2' }] })
      const result = parser.parse('get ball')
      assertEqual(result.type, 'ambiguous')
      assertEqual(result.candidates.length, 2)
    })

    testRunner.register('partial matching works for verbs', () => {
      const parser = createParser({ resolver: () => [{ id: '1' }] })
      const result = parser.parse('exa lamp')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'EXAMINE')
    })

    testRunner.register('partial matching respects minPartialLength', () => {
      const parser = createParser({ resolver: () => [], partialMatch: true, minPartialLength: 4 })
      const result = parser.parse('exa')
      assertEqual(result.type, 'unknown_verb')
    })

    testRunner.register('partial matching can be disabled', () => {
      const parser = createParser({ resolver: () => [], partialMatch: false })
      const result = parser.parse('exa lamp')
      assertEqual(result.type, 'unknown_verb')
    })

    testRunner.register('addVerb adds custom verb', () => {
      const parser = createParser({ resolver: () => [{ id: '1' }] })
      parser.addVerb({ canonical: 'CUSTOM', synonyms: ['custom'], pattern: 'none' })
      const result = parser.parse('custom')
      assertEqual(result.type, 'command')
      assertEqual(result.command.verb, 'CUSTOM')
    })

    testRunner.register('addDirection adds custom direction', () => {
      const parser = createParser({ resolver: () => [] })
      parser.addDirection({ canonical: 'PORTAL', aliases: ['portal'] })
      const result = parser.parse('portal')
      assertEqual(result.type, 'command')
      assertEqual(result.command.direction, 'PORTAL')
    })

    testRunner.register('handles adjectives in subject', () => {
      const parser = createParser({ resolver: (noun, adj) => adj.length ? [{ id: 'red' }] : [] })
      const result = parser.parse('get red ball')
      assertEqual(result.type, 'command')
      assertEqual(result.command.subject.adjectives[0], 'red')
    })

    testRunner.register('returns parse_error for empty input', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('')
      assertEqual(result.type, 'parse_error')
    })

    testRunner.register('returns parse_error for missing subject', () => {
      const parser = createParser({ resolver: () => [] })
      const result = parser.parse('get')
      assertEqual(result.type, 'parse_error')
    })

    testRunner.register('returns parse_error for missing object in subject_object', () => {
      const parser = createParser({ resolver: (noun) => [{ id: noun }] })
      const result = parser.parse('put key')
      assertEqual(result.type, 'parse_error')
    })

    testRunner.register('clearPronoun clears the referent', () => {
      const parser = createParser({ resolver: () => [{ id: '1' }] })
      parser.parse('get lamp')
      parser.clearPronoun()
      const result = parser.parse('examine it')
      assertEqual(result.type, 'parse_error')
      assert(result.message.includes('it'), 'Error should mention "it"')
    })

    testRunner.register('parser instances are isolated', () => {
      const parser1 = createParser({ resolver: () => [] })
      const parser2 = createParser({ resolver: () => [] })
      parser1.addVerb({ canonical: 'TEST', synonyms: ['test'], pattern: 'none' })
      const result1 = parser1.parse('test')
      const result2 = parser2.parse('test')
      assertEqual(result1.type, 'command')
      assertEqual(result2.type, 'unknown_verb')
    })

    testRunner.register('handles multiple prepositions correctly', () => {
      const parser = createParser({ resolver: (noun) => [{ id: noun }] })
      const result = parser.parse('put sword on table')
      assertEqual(result.type, 'command')
      assertEqual(result.command.preposition, 'on')
    })

    testRunner.register('all 12 directions are recognized', () => {
      const parser = createParser({ resolver: () => [] })
      const directions = ['north', 'south', 'east', 'west', 'northeast', 'northwest',
                          'southeast', 'southwest', 'up', 'down', 'in', 'out']
      for (const dir of directions) {
        const result = parser.parse(dir)
        assertEqual(result.type, 'command', `Direction ${dir} should be recognized`)
      }
    })

    testRunner.register('verb synonyms all work', () => {
      const parser = createParser({ resolver: () => [{ id: '1' }] })
      const synonyms = ['get', 'take', 'grab', 'pick']
      for (const syn of synonyms) {
        const result = parser.parse(`${syn} lamp`)
        assertEqual(result.type, 'command')
        assertEqual(result.command.verb, 'GET', `Synonym ${syn} should map to GET`)
      }
    })

    document.getElementById('run-tests').addEventListener('click', () => testRunner.run())

    // Fuzz test runner
    document.getElementById('run-fuzz').addEventListener('click', async () => {
      const output = document.getElementById('test-output')
      const progressFill = document.getElementById('progress-fill')
      const progressText = document.getElementById('progress-text')

      output.innerHTML = ''
      progressFill.style.width = '0%'
      progressFill.className = 'test-progress-fill'

      const parser = createParser({ resolver: () => [{ id: 'test' }] })
      const iterations = 100
      let passed = 0
      let failed = 0

      for (let i = 0; i < iterations; i++) {
        // Generate random input
        const length = Math.floor(Math.random() * 50) + 1
        let input = ''
        for (let j = 0; j < length; j++) {
          input += String.fromCharCode(Math.floor(Math.random() * 94) + 32)
        }

        try {
          const result = parser.parse(input)
          // Should always return a valid result type
          const validTypes = ['command', 'unknown_verb', 'unknown_noun', 'ambiguous', 'parse_error']
          if (!validTypes.includes(result.type)) {
            throw new Error(`Invalid result type: ${result.type}`)
          }
          passed++
        } catch (e) {
          failed++
          output.innerHTML += `
            <div class="test-item">
              <span class="test-icon fail">âœ—</span>
              <div>
                <div class="test-name">Fuzz input: "${escapeHtml(input.slice(0, 30))}..."</div>
                <div class="test-error">${escapeHtml(e.message)}</div>
              </div>
            </div>
          `
        }

        progressFill.style.width = `${((i + 1) / iterations) * 100}%`
        progressText.textContent = `Fuzz testing: ${i + 1}/${iterations}`

        if (i % 10 === 0) {
          await new Promise(r => setTimeout(r, 10))
        }
      }

      progressFill.classList.add(failed === 0 ? 'success' : 'failure')
      progressText.textContent = `Fuzz testing complete: ${passed}/${iterations} passed`

      if (failed === 0) {
        output.innerHTML += `
          <div class="test-item">
            <span class="test-icon pass">âœ“</span>
            <span class="test-name">All ${iterations} random inputs handled gracefully</span>
          </div>
        `
      }

      document.getElementById('passed-count').textContent = passed
      document.getElementById('failed-count').textContent = failed
      document.getElementById('skipped-count').textContent = 0
      document.getElementById('test-summary').classList.remove('hidden')
    })
  </script>
</body>
</html>
