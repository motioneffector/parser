<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/parser - Demo</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f8f9fa;
      color: #333;
    }
    h1 { color: #2c3e50; margin-bottom: 10px; }
    h2 { color: #34495e; margin-top: 0; }
    p { color: #555; }
    section {
      margin: 20px 0;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .test-pass { color: #27ae60; }
    .test-fail { color: #e74c3c; font-weight: bold; }
    .test-output {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      max-height: 400px;
      overflow-y: auto;
      border-radius: 4px;
      margin-top: 15px;
    }
    .test-output .test-pass { color: #6aff6a; }
    .test-output .test-fail { color: #ff6a6a; }
    button {
      padding: 10px 20px;
      margin: 4px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover { filter: brightness(1.1); }
    .run-all {
      background: #27ae60;
      color: white;
      font-size: 16px;
      padding: 14px 28px;
      font-weight: bold;
    }
    .btn-secondary {
      background: #95a5a6;
      color: white;
    }
    .btn-primary {
      background: #3498db;
      color: white;
    }
    .summary {
      font-size: 20px;
      font-weight: bold;
      margin-top: 15px;
      padding: 10px;
      border-radius: 4px;
    }
    .summary.pass { background: #d4edda; color: #155724; }
    .summary.fail { background: #f8d7da; color: #721c24; }
    input[type="text"] {
      padding: 10px;
      font-size: 14px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 100%;
      max-width: 500px;
      margin: 5px 0;
    }
    .input-group {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    .input-group input {
      flex: 1;
      min-width: 200px;
    }
    .output-area {
      background: #f5f5f5;
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      min-height: 100px;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 10px;
    }
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 15px;
    }
    .feature-card {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border-left: 3px solid #3498db;
    }
    .feature-card h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #2c3e50;
    }
    .feature-card code {
      display: block;
      background: #e9ecef;
      padding: 8px;
      border-radius: 3px;
      font-size: 12px;
      color: #495057;
    }
    code {
      background: #e9ecef;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .error-output {
      color: #e74c3c;
      font-weight: bold;
    }
    .success-output {
      color: #27ae60;
    }
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 5px;
      color: #2c3e50;
    }
    .hint {
      font-size: 12px;
      color: #777;
      margin-top: 5px;
    }
    .result-type {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
      margin-right: 5px;
    }
    .result-type.command { background: #d4edda; color: #155724; }
    .result-type.unknown_verb { background: #fff3cd; color: #856404; }
    .result-type.unknown_noun { background: #fff3cd; color: #856404; }
    .result-type.ambiguous { background: #cce5ff; color: #004085; }
    .result-type.parse_error { background: #f8d7da; color: #721c24; }
  </style>
</head>
<body>
  <h1>@motioneffector/parser Demo</h1>
  <p>Text adventure command parser for natural language game input. Parse player commands like "get the red ball" or "hit barrel with hammer" into structured command objects.</p>

  <section id="test-runner">
    <h2>Automated Tests</h2>
    <p>Run the automated test suite to verify all parser functionality.</p>
    <button class="run-all" onclick="runAllTests()">Run All Tests</button>
    <button class="btn-secondary" onclick="clearResults()">Clear Results</button>
    <div class="summary" id="summary"></div>
    <div class="test-output" id="test-output"></div>
  </section>

  <section>
    <h2>Interactive Parser</h2>
    <p>Try parsing commands yourself. The demo uses a mock game world with some objects.</p>

    <label for="parse-input">Enter a command:</label>
    <div class="input-group">
      <input type="text" id="parse-input" placeholder="e.g., get the red ball" onkeypress="if(event.key==='Enter') parseCommand()">
      <button class="btn-primary" onclick="parseCommand()">Parse</button>
      <button class="btn-secondary" onclick="document.getElementById('parse-input').value=''; document.getElementById('parse-output').textContent='Enter a command above'">Clear</button>
    </div>
    <p class="hint">Try: "look", "north", "get lamp", "examine red ball", "put key in chest", "say hello world", "inventory"</p>

    <div class="output-area" id="parse-output">Enter a command above</div>

    <h3 style="margin-top: 20px;">Available Objects in Mock World</h3>
    <div class="feature-grid">
      <div class="feature-card">
        <h3>lamp</h3>
        <code>A brass lamp, slightly dented</code>
      </div>
      <div class="feature-card">
        <h3>red ball, blue ball</h3>
        <code>Two balls of different colors</code>
      </div>
      <div class="feature-card">
        <h3>key</h3>
        <code>A rusty old key</code>
      </div>
      <div class="feature-card">
        <h3>chest</h3>
        <code>A wooden treasure chest</code>
      </div>
      <div class="feature-card">
        <h3>sword</h3>
        <code>A gleaming steel sword</code>
      </div>
      <div class="feature-card">
        <h3>door</h3>
        <code>A heavy oak door</code>
      </div>
    </div>
  </section>

  <section>
    <h2>Error Cases</h2>
    <p>Test how the parser handles various error conditions.</p>

    <div class="feature-grid">
      <div class="feature-card">
        <h3>Unknown Verb</h3>
        <button class="btn-secondary" onclick="testError('xyzzy')">Try "xyzzy"</button>
      </div>
      <div class="feature-card">
        <h3>Unknown Noun</h3>
        <button class="btn-secondary" onclick="testError('get grommet')">Try "get grommet"</button>
      </div>
      <div class="feature-card">
        <h3>Missing Object</h3>
        <button class="btn-secondary" onclick="testError('get')">Try "get" (no object)</button>
      </div>
      <div class="feature-card">
        <h3>Incomplete Command</h3>
        <button class="btn-secondary" onclick="testError('put key')">Try "put key" (no destination)</button>
      </div>
      <div class="feature-card">
        <h3>Ambiguous</h3>
        <button class="btn-secondary" onclick="testError('get ball')">Try "get ball" (red or blue?)</button>
      </div>
      <div class="feature-card">
        <h3>Empty Input</h3>
        <button class="btn-secondary" onclick="testError('')">Try empty string</button>
      </div>
    </div>

    <div class="output-area" id="error-output">Click a button above to test error handling</div>
  </section>

  <section>
    <h2>Pronoun Support</h2>
    <p>The parser tracks the last successfully referenced object so you can use "it".</p>

    <div class="input-group">
      <button class="btn-primary" onclick="testPronoun('get lamp')">1. "get lamp"</button>
      <button class="btn-primary" onclick="testPronoun('examine it')">2. "examine it"</button>
      <button class="btn-primary" onclick="testPronoun('drop it')">3. "drop it"</button>
      <button class="btn-secondary" onclick="clearPronounDemo()">Reset</button>
    </div>
    <p class="hint">Click in sequence to see how "it" refers back to the lamp.</p>

    <div class="output-area" id="pronoun-output">Click the buttons in sequence above</div>
  </section>

  <section>
    <h2>Custom Vocabulary</h2>
    <p>Add custom verbs and directions at runtime.</p>

    <div class="input-group">
      <button class="btn-primary" onclick="addCustomVerb()">Add "zap" verb</button>
      <button class="btn-primary" onclick="testCustomVerb()">Try "zap lamp"</button>
      <button class="btn-secondary" onclick="resetCustomDemo()">Reset Parser</button>
    </div>
    <p class="hint">The "zap" verb is not in the default vocabulary. Add it first, then test it.</p>

    <div class="output-area" id="custom-output">Click "Add zap verb" first, then test it</div>
  </section>

  <section>
    <h2>Supported Command Patterns</h2>
    <p>The parser recognizes these command structures:</p>

    <div class="feature-grid">
      <div class="feature-card">
        <h3>VERB (none)</h3>
        <code>look, inventory, quit</code>
      </div>
      <div class="feature-card">
        <h3>DIRECTION</h3>
        <code>north, n, northeast, up, in</code>
      </div>
      <div class="feature-card">
        <h3>GO DIRECTION</h3>
        <code>go north, walk east</code>
      </div>
      <div class="feature-card">
        <h3>VERB NOUN</h3>
        <code>get lamp, examine door</code>
      </div>
      <div class="feature-card">
        <h3>VERB ADJECTIVE NOUN</h3>
        <code>get red ball, take rusty key</code>
      </div>
      <div class="feature-card">
        <h3>VERB NOUN PREP NOUN</h3>
        <code>put key in chest, hit door with sword</code>
      </div>
      <div class="feature-card">
        <h3>VERB TEXT</h3>
        <code>say hello world, shout help me</code>
      </div>
    </div>
  </section>

  <script>
    // ============================================
    // INLINED LIBRARY CODE (from dist/index.js)
    // ============================================
    class L extends Error {
      constructor(u) {
        super(u), this.name = "ParserError", Object.setPrototypeOf(this, new.target.prototype);
      }
    }
    class $ extends L {
      constructor(u, t) {
        super(u), this.field = t, this.name = "ValidationError";
      }
    }
    class H extends L {
      constructor(u, t, g) {
        super(u), this.position = t, this.input = g, this.name = "ParseError";
      }
    }
    function N(n) {
      const u = [];
      let t = 0;
      for (; t < n.length; ) {
        const g = n[t];
        if (g && /\s/.test(g)) {
          t++;
          continue;
        }
        if (g === '"' || g === "'") {
          const m = g, b = t;
          t++;
          let d = "", T = !1;
          for (; t < n.length; ) {
            const p = n[t];
            if (!p) break;
            if (p === "\\" && t + 1 < n.length) {
              const k = n[t + 1];
              if (k === m || k === "\\") {
                d += k, t += 2;
                continue;
              }
            }
            if (p === m) {
              T = !0, t++;
              break;
            }
            d += p, t++;
          }
          T || (d = n.slice(b + 1), t = n.length), u.push({
            type: "QUOTED_STRING",
            value: d,
            original: n.slice(b, t),
            start: b,
            end: t
          });
          continue;
        }
        if (g && /[a-zA-Z0-9_\u0080-\uFFFF]/.test(g)) {
          const m = t;
          let b = "";
          for (; t < n.length; ) {
            const p = n[t];
            if (p && /[a-zA-Z0-9_\u0080-\uFFFF]/.test(p))
              b += p, t++;
            else
              break;
          }
          let d = b;
          for (; d.length > 0; ) {
            const p = d[d.length - 1];
            if (p && /[.,!?;:]/.test(p))
              d = d.slice(0, -1), t--;
            else
              break;
          }
          for (; t < n.length; ) {
            const p = n[t];
            if (p && /[.,!?;:]/.test(p))
              t++;
            else
              break;
          }
          const T = n.slice(m, m + b.length);
          u.push({
            type: "WORD",
            value: d.toLowerCase(),
            original: T,
            start: m,
            end: m + b.length
          });
          continue;
        }
        t++;
      }
      return u;
    }
    const A = {
      verbs: [
        { canonical: "GO", synonyms: ["go", "walk", "run"], pattern: "direction" },
        { canonical: "ENTER", synonyms: ["enter"], pattern: "subject" },
        { canonical: "EXIT", synonyms: ["exit", "leave"], pattern: "none" },
        { canonical: "CLIMB", synonyms: ["climb"], pattern: "subject" },
        { canonical: "GET", synonyms: ["get", "take", "grab", "pick"], pattern: "subject" },
        { canonical: "DROP", synonyms: ["drop"], pattern: "subject" },
        { canonical: "PUT", synonyms: ["put"], pattern: "subject_object" },
        { canonical: "GIVE", synonyms: ["give"], pattern: "subject_object" },
        { canonical: "THROW", synonyms: ["throw"], pattern: "subject_object" },
        { canonical: "OPEN", synonyms: ["open"], pattern: "subject" },
        { canonical: "CLOSE", synonyms: ["close"], pattern: "subject" },
        { canonical: "LOCK", synonyms: ["lock"], pattern: "subject" },
        { canonical: "UNLOCK", synonyms: ["unlock"], pattern: "subject" },
        { canonical: "LOOK", synonyms: ["look", "l"], pattern: "none" },
        { canonical: "EXAMINE", synonyms: ["examine", "x", "inspect"], pattern: "subject" },
        { canonical: "SEARCH", synonyms: ["search"], pattern: "subject" },
        { canonical: "READ", synonyms: ["read"], pattern: "subject" },
        { canonical: "SAY", synonyms: ["say"], pattern: "text" },
        { canonical: "SHOUT", synonyms: ["shout"], pattern: "text" },
        { canonical: "TALK", synonyms: ["talk"], pattern: "subject" },
        { canonical: "ASK", synonyms: ["ask"], pattern: "subject_object" },
        { canonical: "TELL", synonyms: ["tell"], pattern: "subject_object" },
        { canonical: "ATTACK", synonyms: ["attack", "hit", "strike"], pattern: "subject" },
        { canonical: "KILL", synonyms: ["kill"], pattern: "subject" },
        { canonical: "FIGHT", synonyms: ["fight"], pattern: "subject" },
        { canonical: "INVENTORY", synonyms: ["inventory", "i", "inv"], pattern: "none" },
        { canonical: "SCORE", synonyms: ["score"], pattern: "none" },
        { canonical: "SAVE", synonyms: ["save"], pattern: "none" },
        { canonical: "LOAD", synonyms: ["load"], pattern: "none" },
        { canonical: "QUIT", synonyms: ["quit"], pattern: "none" },
        { canonical: "HELP", synonyms: ["help"], pattern: "none" }
      ],
      directions: [
        { canonical: "NORTH", aliases: ["north", "n"] },
        { canonical: "SOUTH", aliases: ["south", "s"] },
        { canonical: "EAST", aliases: ["east", "e"] },
        { canonical: "WEST", aliases: ["west", "w"] },
        { canonical: "NORTHEAST", aliases: ["northeast", "ne"] },
        { canonical: "NORTHWEST", aliases: ["northwest", "nw"] },
        { canonical: "SOUTHEAST", aliases: ["southeast", "se"] },
        { canonical: "SOUTHWEST", aliases: ["southwest", "sw"] },
        { canonical: "UP", aliases: ["up", "u"] },
        { canonical: "DOWN", aliases: ["down", "d"] },
        { canonical: "IN", aliases: ["in"] },
        { canonical: "OUT", aliases: ["out"] }
      ],
      prepositions: ["with", "to", "at", "in", "on", "from", "into", "onto", "about"],
      articles: ["the", "a", "an"]
    };
    function F(n) {
      if (typeof n.resolver != "function")
        throw new $("Resolver must be a function", "resolver");
      const u = U(n.vocabulary), t = n.partialMatch ?? !0, g = n.minPartialLength ?? 3;
      let m = null, b = null;
      function d(s) {
        for (const c of u.verbs)
          if (c.synonyms.includes(s))
            return c;
        if (t && s.length >= g) {
          for (const c of u.verbs)
            for (const x of c.synonyms)
              if (x.startsWith(s))
                return c;
        }
        return null;
      }
      function T(s) {
        for (const c of u.directions)
          if (c.aliases.includes(s))
            return c.canonical;
        return null;
      }
      function p(s) {
        return u.articles.includes(s);
      }
      function k(s) {
        return u.prepositions.includes(s);
      }
      function S(s, c, x) {
        let l = c;
        const e = [];
        let j = null;
        for (; l < s.length; ) {
          const o = s[l];
          if (o && p(o.value))
            l++;
          else
            break;
        }
        const _ = s[l];
        if ((_ == null ? void 0 : _.value) === "it")
          return m ? { entity: m, consumed: l - c + 1 } : {
            entity: null,
            consumed: l - c + 1,
            error: {
              type: "parse_error",
              message: 'Cannot use "it" without a previous referent',
              position: _.start
            }
          };
        const a = [];
        for (; l < s.length; ) {
          const o = s[l];
          if (!o || k(o.value) || T(o.value)) break;
          p(o.value) || a.push(o.value), l++;
        }
        if (a.length === 0)
          return { entity: null, consumed: 0 };
        const f = a[a.length - 1];
        if (!f)
          return { entity: null, consumed: 0 };
        j = f, a.length > 1 && e.push(...a.slice(0, -1));
        const i = n.resolver(j, e, x ?? {});
        if (i.length === 0) {
          const o = s[c];
          return {
            entity: null,
            consumed: l - c,
            error: {
              type: "unknown_noun",
              noun: j,
              position: o ? o.start : 0
            }
          };
        }
        if (i.length > 1)
          return {
            entity: null,
            consumed: l - c,
            error: {
              type: "ambiguous",
              candidates: i,
              original: a.join(" "),
              role: "subject"
            }
          };
        const E = i[0];
        return E ? { entity: {
          id: E.id,
          noun: j,
          adjectives: e
        }, consumed: l - c } : { entity: null, consumed: 0 };
      }
      function R(s, c) {
        const x = s, l = c == null ? void 0 : c.scope;
        l && l.room !== b && (m = null, b = l.room);
        const e = N(s);
        if (e.length === 0)
          return {
            type: "parse_error",
            message: "Empty input",
            position: 0
          };
        const j = e[0];
        if (!j)
          return {
            type: "parse_error",
            message: "Empty input",
            position: 0
          };
        const _ = T(j.value);
        if (_)
          return { type: "command", command: {
            verb: "GO",
            direction: _,
            raw: x
          } };
        const a = d(j.value);
        if (!a)
          return {
            type: "unknown_verb",
            verb: j.value
          };
        const f = {
          verb: a.canonical,
          raw: x
        };
        if (a.pattern === "none")
          return { type: "command", command: f };
        if (a.pattern === "direction") {
          if (e.length < 2) {
            const h = e[e.length - 1];
            return {
              type: "parse_error",
              message: `Expected direction after "${a.canonical}"`,
              position: h ? h.end : 0
            };
          }
          const i = e[1];
          if (!i)
            return {
              type: "parse_error",
              message: `Expected direction after "${a.canonical}"`,
              position: 0
            };
          const E = T(i.value);
          return E ? (f.direction = E, { type: "command", command: f }) : {
            type: "parse_error",
            message: `Expected direction, got "${i.value}"`,
            position: i.start
          };
        }
        if (a.pattern === "text") {
          if (e.length < 2) {
            const h = e[e.length - 1];
            return {
              type: "parse_error",
              message: `Expected text after "${a.canonical}"`,
              position: h ? h.end : 0
            };
          }
          const i = e[1];
          if (!i)
            return {
              type: "parse_error",
              message: `Expected text after "${a.canonical}"`,
              position: 0
            };
          const E = i.start;
          return f.text = x.slice(E).trim(), { type: "command", command: f };
        }
        if (a.pattern === "subject") {
          if (e.length < 2) {
            const r = e[e.length - 1];
            return {
              type: "parse_error",
              message: `Expected object after "${a.canonical}"`,
              position: r ? r.end : 0
            };
          }
          const { entity: i, consumed: E, error: h } = S(e, 1, l);
          if (h)
            return h;
          if (!i) {
            const r = e[1];
            return {
              type: "parse_error",
              message: `Expected object after "${a.canonical}"`,
              position: r ? r.start : 0
            };
          }
          f.subject = i;
          const o = 1 + E;
          if (o < e.length) {
            const r = e[o];
            if (r && k(r.value)) {
              if (f.preposition = r.value, o + 1 >= e.length)
                return {
                  type: "parse_error",
                  message: `Expected target after "${r.value}"`,
                  position: r.end
                };
              const {
                entity: w,
                error: v
              } = S(e, o + 1, l);
              if (v)
                return v.type === "ambiguous" ? { ...v, role: "object" } : v;
              if (!w) {
                const y = e[o + 1];
                return {
                  type: "parse_error",
                  message: `Expected target after "${r.value}"`,
                  position: y ? y.start : 0
                };
              }
              f.object = w;
            }
          }
          return m = i, { type: "command", command: f };
        }
        {
          if (e.length < 2) {
            const y = e[e.length - 1];
            return {
              type: "parse_error",
              message: `Expected object after "${a.canonical}"`,
              position: y ? y.end : 0
            };
          }
          const { entity: i, consumed: E, error: h } = S(
            e,
            1,
            l
          );
          if (h)
            return h;
          if (!i) {
            const y = e[1];
            return {
              type: "parse_error",
              message: `Expected object after "${a.canonical}"`,
              position: y ? y.start : 0
            };
          }
          f.subject = i;
          const o = 1 + E;
          if (o >= e.length) {
            const y = e[e.length - 1];
            return {
              type: "parse_error",
              message: "Expected preposition and target",
              position: y ? y.end : 0
            };
          }
          const r = e[o];
          if (!r || !k(r.value)) {
            const y = e[e.length - 1];
            return {
              type: "parse_error",
              message: `Expected preposition, got "${(r == null ? void 0 : r.value) ?? "nothing"}"`,
              position: (r == null ? void 0 : r.start) ?? (y ? y.end : 0)
            };
          }
          if (f.preposition = r.value, o + 1 >= e.length)
            return {
              type: "parse_error",
              message: `Expected target after "${r.value}"`,
              position: r.end
            };
          const {
            entity: w,
            error: v
          } = S(e, o + 1, l);
          if (v)
            return v.type === "ambiguous" ? { ...v, role: "object" } : v;
          if (!w) {
            const y = e[o + 1];
            return {
              type: "parse_error",
              message: `Expected target after "${r.value}"`,
              position: y ? y.start : 0
            };
          }
          return f.object = w, m = i, { type: "command", command: f };
        }
      }
      function P(s) {
        u.verbs.push(s);
      }
      function C(s) {
        u.directions.push(s);
      }
      function O() {
        m = null;
      }
      return {
        parse: R,
        addVerb: P,
        addDirection: C,
        clearPronoun: O
      };
    }
    function U(n) {
      return n ? n.extend ?? !0 ? {
        verbs: [...A.verbs, ...n.verbs ?? []],
        directions: [...A.directions, ...n.directions ?? []],
        prepositions: [...A.prepositions, ...n.prepositions ?? []],
        articles: [...A.articles, ...n.articles ?? []]
      } : {
        verbs: n.verbs ?? [],
        directions: n.directions ?? [],
        prepositions: n.prepositions ?? [],
        articles: n.articles ?? []
      } : { ...A };
    }

    // Expose to window for demo
    window.createParser = F;
    window.ValidationError = $;
    window.ParseError = H;
    window.ParserError = L;
    // ============================================
  </script>

  <script>
    // ============================================
    // DEMO AND TEST CODE
    // ============================================

    // Mock game world for demos
    const gameWorld = {
      lamp: { id: 'lamp-1', name: 'lamp', adjectives: [] },
      redBall: { id: 'ball-red', name: 'ball', adjectives: ['red'] },
      blueBall: { id: 'ball-blue', name: 'ball', adjectives: ['blue'] },
      key: { id: 'key-1', name: 'key', adjectives: ['rusty', 'old'] },
      chest: { id: 'chest-1', name: 'chest', adjectives: ['wooden'] },
      sword: { id: 'sword-1', name: 'sword', adjectives: ['steel', 'gleaming'] },
      door: { id: 'door-1', name: 'door', adjectives: ['oak', 'heavy'] }
    };

    // Resolver function for the mock world
    function mockResolver(noun, adjectives, scope) {
      const allObjects = Object.values(gameWorld);

      // Filter by noun
      let matches = allObjects.filter(obj => obj.name === noun);

      // Filter by adjectives if provided
      if (adjectives.length > 0) {
        matches = matches.filter(obj =>
          adjectives.every(adj => obj.adjectives.includes(adj))
        );
      }

      return matches;
    }

    // Create parser instance for demos
    let parser = createParser({ resolver: mockResolver });
    let pronounParser = createParser({ resolver: mockResolver });
    let customParser = createParser({ resolver: mockResolver });

    // ============================================
    // AUTOMATED TESTS
    // ============================================

    const tests = [
      // createParser tests
      {
        name: 'createParser: returns object with parse method',
        fn: () => {
          const p = createParser({ resolver: () => [] });
          if (typeof p.parse !== 'function') throw new Error('parse is not a function');
        }
      },
      {
        name: 'createParser: returns object with addVerb method',
        fn: () => {
          const p = createParser({ resolver: () => [] });
          if (typeof p.addVerb !== 'function') throw new Error('addVerb is not a function');
        }
      },
      {
        name: 'createParser: returns object with addDirection method',
        fn: () => {
          const p = createParser({ resolver: () => [] });
          if (typeof p.addDirection !== 'function') throw new Error('addDirection is not a function');
        }
      },
      {
        name: 'createParser: returns object with clearPronoun method',
        fn: () => {
          const p = createParser({ resolver: () => [] });
          if (typeof p.clearPronoun !== 'function') throw new Error('clearPronoun is not a function');
        }
      },
      {
        name: 'createParser: throws when resolver is not a function',
        fn: () => {
          try {
            createParser({ resolver: 'not a function' });
            throw new Error('Should have thrown');
          } catch (e) {
            if (e.name !== 'ValidationError') throw new Error(`Expected ValidationError, got ${e.name}`);
          }
        }
      },

      // Direction parsing tests
      {
        name: 'parses "north" as direction command',
        fn: () => {
          const result = parser.parse('north');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.direction !== 'NORTH') throw new Error(`Expected NORTH, got ${result.command.direction}`);
        }
      },
      {
        name: 'parses "n" as direction shortcut',
        fn: () => {
          const result = parser.parse('n');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.direction !== 'NORTH') throw new Error(`Expected NORTH, got ${result.command.direction}`);
        }
      },
      {
        name: 'parses "northeast" as compound direction',
        fn: () => {
          const result = parser.parse('northeast');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.direction !== 'NORTHEAST') throw new Error(`Expected NORTHEAST, got ${result.command.direction}`);
        }
      },
      {
        name: 'parses "ne" as compound direction shortcut',
        fn: () => {
          const result = parser.parse('ne');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.direction !== 'NORTHEAST') throw new Error(`Expected NORTHEAST, got ${result.command.direction}`);
        }
      },
      {
        name: 'parses "up" as vertical direction',
        fn: () => {
          const result = parser.parse('up');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.direction !== 'UP') throw new Error(`Expected UP, got ${result.command.direction}`);
        }
      },
      {
        name: 'parses "go north" as direction command',
        fn: () => {
          const result = parser.parse('go north');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'GO') throw new Error(`Expected GO, got ${result.command.verb}`);
          if (result.command.direction !== 'NORTH') throw new Error(`Expected NORTH, got ${result.command.direction}`);
        }
      },

      // Verb-only commands
      {
        name: 'parses "look" as verb-only command',
        fn: () => {
          const result = parser.parse('look');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'LOOK') throw new Error(`Expected LOOK, got ${result.command.verb}`);
        }
      },
      {
        name: 'parses "inventory" as verb-only command',
        fn: () => {
          const result = parser.parse('inventory');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'INVENTORY') throw new Error(`Expected INVENTORY, got ${result.command.verb}`);
        }
      },
      {
        name: 'parses "i" as inventory shortcut',
        fn: () => {
          const result = parser.parse('i');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'INVENTORY') throw new Error(`Expected INVENTORY, got ${result.command.verb}`);
        }
      },
      {
        name: 'parses "l" as look shortcut',
        fn: () => {
          const result = parser.parse('l');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'LOOK') throw new Error(`Expected LOOK, got ${result.command.verb}`);
        }
      },

      // VERB NOUN commands
      {
        name: 'parses "get lamp" with subject',
        fn: () => {
          const result = parser.parse('get lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'GET') throw new Error(`Expected GET, got ${result.command.verb}`);
          if (!result.command.subject) throw new Error('Expected subject');
          if (result.command.subject.id !== 'lamp-1') throw new Error(`Expected lamp-1, got ${result.command.subject.id}`);
        }
      },
      {
        name: 'parses "take lamp" as GET synonym',
        fn: () => {
          const result = parser.parse('take lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'GET') throw new Error(`Expected GET, got ${result.command.verb}`);
        }
      },
      {
        name: 'parses "examine door" with subject',
        fn: () => {
          const result = parser.parse('examine door');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'EXAMINE') throw new Error(`Expected EXAMINE, got ${result.command.verb}`);
          if (!result.command.subject) throw new Error('Expected subject');
        }
      },
      {
        name: 'parses "x door" as examine shortcut',
        fn: () => {
          const result = parser.parse('x door');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'EXAMINE') throw new Error(`Expected EXAMINE, got ${result.command.verb}`);
        }
      },

      // VERB ADJECTIVE NOUN commands
      {
        name: 'parses "get red ball" with adjective',
        fn: () => {
          const result = parser.parse('get red ball');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (!result.command.subject) throw new Error('Expected subject');
          if (result.command.subject.id !== 'ball-red') throw new Error(`Expected ball-red, got ${result.command.subject.id}`);
          if (!result.command.subject.adjectives.includes('red')) throw new Error('Expected red adjective');
        }
      },
      {
        name: 'parses "get blue ball" with adjective',
        fn: () => {
          const result = parser.parse('get blue ball');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (!result.command.subject) throw new Error('Expected subject');
          if (result.command.subject.id !== 'ball-blue') throw new Error(`Expected ball-blue, got ${result.command.subject.id}`);
        }
      },
      {
        name: 'parses "examine rusty key" with adjective',
        fn: () => {
          const result = parser.parse('examine rusty key');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (!result.command.subject) throw new Error('Expected subject');
          if (result.command.subject.id !== 'key-1') throw new Error(`Expected key-1, got ${result.command.subject.id}`);
        }
      },

      // Articles
      {
        name: 'strips article "the" from command',
        fn: () => {
          const result = parser.parse('get the lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (!result.command.subject) throw new Error('Expected subject');
          if (result.command.subject.id !== 'lamp-1') throw new Error(`Expected lamp-1, got ${result.command.subject.id}`);
        }
      },
      {
        name: 'strips article "a" from command',
        fn: () => {
          const result = parser.parse('get a lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (!result.command.subject) throw new Error('Expected subject');
        }
      },

      // VERB NOUN PREP NOUN commands
      {
        name: 'parses "put key in chest" with subject and object',
        fn: () => {
          const result = parser.parse('put key in chest');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'PUT') throw new Error(`Expected PUT, got ${result.command.verb}`);
          if (!result.command.subject) throw new Error('Expected subject');
          if (!result.command.object) throw new Error('Expected object');
          if (result.command.preposition !== 'in') throw new Error(`Expected preposition 'in', got ${result.command.preposition}`);
        }
      },
      {
        name: 'parses "hit door with sword"',
        fn: () => {
          const result = parser.parse('hit door with sword');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'ATTACK') throw new Error(`Expected ATTACK, got ${result.command.verb}`);
          if (!result.command.subject) throw new Error('Expected subject');
          if (!result.command.object) throw new Error('Expected object');
          if (result.command.preposition !== 'with') throw new Error(`Expected preposition 'with', got ${result.command.preposition}`);
        }
      },
      {
        name: 'parses "give sword to door"',
        fn: () => {
          const result = parser.parse('give sword to door');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'GIVE') throw new Error(`Expected GIVE, got ${result.command.verb}`);
          if (result.command.preposition !== 'to') throw new Error(`Expected preposition 'to', got ${result.command.preposition}`);
        }
      },

      // VERB TEXT commands
      {
        name: 'parses "say hello" capturing text',
        fn: () => {
          const result = parser.parse('say hello');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'SAY') throw new Error(`Expected SAY, got ${result.command.verb}`);
          if (result.command.text !== 'hello') throw new Error(`Expected 'hello', got '${result.command.text}'`);
        }
      },
      {
        name: 'parses "say hello there friend" as single text',
        fn: () => {
          const result = parser.parse('say hello there friend');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.text !== 'hello there friend') throw new Error(`Expected 'hello there friend', got '${result.command.text}'`);
        }
      },

      // Unknown verb
      {
        name: 'returns unknown_verb for unrecognized verb',
        fn: () => {
          const result = parser.parse('xyzzy');
          if (result.type !== 'unknown_verb') throw new Error(`Expected unknown_verb, got ${result.type}`);
          if (result.verb !== 'xyzzy') throw new Error(`Expected 'xyzzy', got '${result.verb}'`);
        }
      },

      // Unknown noun
      {
        name: 'returns unknown_noun when resolver returns empty',
        fn: () => {
          const result = parser.parse('get grommet');
          if (result.type !== 'unknown_noun') throw new Error(`Expected unknown_noun, got ${result.type}`);
          if (result.noun !== 'grommet') throw new Error(`Expected 'grommet', got '${result.noun}'`);
        }
      },

      // Parse errors
      {
        name: 'returns parse_error for "get" with no noun',
        fn: () => {
          const result = parser.parse('get');
          if (result.type !== 'parse_error') throw new Error(`Expected parse_error, got ${result.type}`);
        }
      },
      {
        name: 'returns parse_error for "put key" with no destination',
        fn: () => {
          const result = parser.parse('put key');
          if (result.type !== 'parse_error') throw new Error(`Expected parse_error, got ${result.type}`);
        }
      },
      {
        name: 'returns parse_error for empty input',
        fn: () => {
          const result = parser.parse('');
          if (result.type !== 'parse_error') throw new Error(`Expected parse_error, got ${result.type}`);
        }
      },
      {
        name: 'returns parse_error for whitespace-only input',
        fn: () => {
          const result = parser.parse('   ');
          if (result.type !== 'parse_error') throw new Error(`Expected parse_error, got ${result.type}`);
        }
      },

      // Ambiguous results
      {
        name: 'returns ambiguous when multiple objects match',
        fn: () => {
          const result = parser.parse('get ball');
          if (result.type !== 'ambiguous') throw new Error(`Expected ambiguous, got ${result.type}`);
          if (result.candidates.length !== 2) throw new Error(`Expected 2 candidates, got ${result.candidates.length}`);
        }
      },

      // Pronoun handling
      {
        name: 'tracks last resolved entity for "it"',
        fn: () => {
          const p = createParser({ resolver: mockResolver });
          const result1 = p.parse('get lamp');
          if (result1.type !== 'command') throw new Error(`Expected command, got ${result1.type}`);
          const result2 = p.parse('examine it');
          if (result2.type !== 'command') throw new Error(`Expected command, got ${result2.type}`);
          if (!result2.command.subject) throw new Error('Expected subject');
          if (result2.command.subject.id !== 'lamp-1') throw new Error(`Expected lamp-1, got ${result2.command.subject.id}`);
        }
      },
      {
        name: 'returns error if "it" used with no referent',
        fn: () => {
          const p = createParser({ resolver: mockResolver });
          const result = p.parse('examine it');
          if (result.type !== 'parse_error') throw new Error(`Expected parse_error, got ${result.type}`);
        }
      },
      {
        name: 'clearPronoun clears the reference',
        fn: () => {
          const p = createParser({ resolver: mockResolver });
          p.parse('get lamp');
          p.clearPronoun();
          const result = p.parse('examine it');
          if (result.type !== 'parse_error') throw new Error(`Expected parse_error, got ${result.type}`);
        }
      },

      // Custom vocabulary
      {
        name: 'addVerb adds new verb definition',
        fn: () => {
          const p = createParser({ resolver: mockResolver });
          p.addVerb({ canonical: 'ZAP', synonyms: ['zap'], pattern: 'subject' });
          const result = p.parse('zap lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'ZAP') throw new Error(`Expected ZAP, got ${result.command.verb}`);
        }
      },
      {
        name: 'addDirection adds new direction',
        fn: () => {
          const p = createParser({ resolver: mockResolver });
          p.addDirection({ canonical: 'PORTAL', aliases: ['portal', 'p'] });
          const result = p.parse('portal');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.direction !== 'PORTAL') throw new Error(`Expected PORTAL, got ${result.command.direction}`);
        }
      },

      // Raw input preservation
      {
        name: 'command includes raw input',
        fn: () => {
          const result = parser.parse('Get The LAMP');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.raw !== 'Get The LAMP') throw new Error(`Expected 'Get The LAMP', got '${result.command.raw}'`);
        }
      },

      // Case insensitivity
      {
        name: 'handles uppercase input',
        fn: () => {
          const result = parser.parse('GET LAMP');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'GET') throw new Error(`Expected GET, got ${result.command.verb}`);
        }
      },
      {
        name: 'handles mixed case input',
        fn: () => {
          const result = parser.parse('GeT LaMp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
        }
      },

      // Partial matching
      {
        name: 'matches partial verb "exa" to "examine"',
        fn: () => {
          const result = parser.parse('exa lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'EXAMINE') throw new Error(`Expected EXAMINE, got ${result.command.verb}`);
        }
      },

      // Edge cases
      {
        name: 'handles punctuation at end of input',
        fn: () => {
          const result = parser.parse('look.');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.verb !== 'LOOK') throw new Error(`Expected LOOK, got ${result.command.verb}`);
        }
      },
      {
        name: 'handles multiple spaces',
        fn: () => {
          const result = parser.parse('get    lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
        }
      },
      {
        name: 'handles tab characters',
        fn: () => {
          const result = parser.parse('get\tlamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
        }
      },

      // EntityRef structure
      {
        name: 'EntityRef has id property',
        fn: () => {
          const result = parser.parse('get lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (!result.command.subject.id) throw new Error('Expected id property');
        }
      },
      {
        name: 'EntityRef has noun property',
        fn: () => {
          const result = parser.parse('get lamp');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (result.command.subject.noun !== 'lamp') throw new Error(`Expected 'lamp', got '${result.command.subject.noun}'`);
        }
      },
      {
        name: 'EntityRef has adjectives array',
        fn: () => {
          const result = parser.parse('get red ball');
          if (result.type !== 'command') throw new Error(`Expected command, got ${result.type}`);
          if (!Array.isArray(result.command.subject.adjectives)) throw new Error('Expected adjectives array');
        }
      }
    ];

    function logResult(name, status, error) {
      const output = document.getElementById('test-output');
      const className = status === 'PASS' ? 'test-pass' : 'test-fail';
      const errorMsg = error ? ` - ${error}` : '';
      output.innerHTML += `<div class="${className}">[${status}] ${name}${errorMsg}</div>`;
      output.scrollTop = output.scrollHeight;
    }

    function logSummary(passed, failed) {
      const summary = document.getElementById('summary');
      const total = passed + failed;
      const className = failed === 0 ? 'pass' : 'fail';
      summary.className = `summary ${className}`;
      summary.innerHTML = `${passed}/${total} tests passed`;
    }

    async function runAllTests() {
      clearResults();
      let passed = 0, failed = 0;

      for (const test of tests) {
        try {
          await test.fn();
          logResult(test.name, 'PASS');
          passed++;
        } catch (e) {
          logResult(test.name, 'FAIL', e.message);
          failed++;
        }
        // Small delay to show progress
        await new Promise(r => setTimeout(r, 10));
      }

      logSummary(passed, failed);
    }

    function clearResults() {
      document.getElementById('test-output').innerHTML = '';
      document.getElementById('summary').innerHTML = '';
      document.getElementById('summary').className = 'summary';
    }

    // ============================================
    // INTERACTIVE DEMOS
    // ============================================

    function formatResult(result) {
      let output = `<span class="result-type ${result.type}">${result.type.toUpperCase()}</span>\n\n`;
      output += JSON.stringify(result, null, 2);
      return output;
    }

    function parseCommand() {
      const input = document.getElementById('parse-input').value;
      const output = document.getElementById('parse-output');

      try {
        const result = parser.parse(input);
        output.innerHTML = formatResult(result);
      } catch (e) {
        output.innerHTML = `<span class="error-output">Error: ${e.message}</span>`;
      }
    }

    function testError(input) {
      const output = document.getElementById('error-output');

      try {
        const result = parser.parse(input);
        output.innerHTML = `Input: "${input}"\n\n` + formatResult(result);
      } catch (e) {
        output.innerHTML = `Input: "${input}"\n\n<span class="error-output">Exception: ${e.message}</span>`;
      }
    }

    // Pronoun demo
    let pronounLog = [];

    function testPronoun(input) {
      const output = document.getElementById('pronoun-output');

      try {
        const result = pronounParser.parse(input);
        pronounLog.push({ input, result });

        let html = '';
        for (const entry of pronounLog) {
          html += `> ${entry.input}\n`;
          html += JSON.stringify(entry.result, null, 2) + '\n\n';
        }
        output.innerHTML = html;
      } catch (e) {
        output.innerHTML += `\n<span class="error-output">Error: ${e.message}</span>`;
      }
    }

    function clearPronounDemo() {
      pronounParser = createParser({ resolver: mockResolver });
      pronounLog = [];
      document.getElementById('pronoun-output').textContent = 'Click the buttons in sequence above';
    }

    // Custom vocabulary demo
    let customVerbAdded = false;

    function addCustomVerb() {
      const output = document.getElementById('custom-output');

      if (customVerbAdded) {
        output.innerHTML = '<span class="success-output">"zap" verb already added!</span>\n\nTry "zap lamp" now.';
        return;
      }

      customParser.addVerb({
        canonical: 'ZAP',
        synonyms: ['zap', 'blast', 'beam'],
        pattern: 'subject'
      });

      customVerbAdded = true;
      output.innerHTML = '<span class="success-output">Added verb "ZAP" with synonyms: zap, blast, beam</span>\n\nNow try "zap lamp" or "blast sword"!';
    }

    function testCustomVerb() {
      const output = document.getElementById('custom-output');

      if (!customVerbAdded) {
        output.innerHTML = '<span class="error-output">Add the "zap" verb first!</span>';
        return;
      }

      const result = customParser.parse('zap lamp');
      output.innerHTML = 'Parsing: "zap lamp"\n\n' + formatResult(result);
    }

    function resetCustomDemo() {
      customParser = createParser({ resolver: mockResolver });
      customVerbAdded = false;
      document.getElementById('custom-output').textContent = 'Click "Add zap verb" first, then test it';
    }
  </script>
</body>
</html>
