<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Handling Disambiguation - @motioneffector/parser</title>
  <link rel="stylesheet" href="../demo-files/demo.css">
  <link rel="stylesheet" href="manual.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>document.addEventListener('DOMContentLoaded', () => hljs.highlightAll());</script>
</head>
<body>
  <div class="page">
    <header class="header">
      <h1 class="header-title">@motioneffector/parser</h1>
      <p class="header-description">Documentation</p>
      <nav class="header-links">
        <a href="../index.html" class="header-link">Demo</a>
        <a href="https://www.npmjs.com/package/@motioneffector/parser" class="header-link">npm</a>
        <a href="https://github.com/motioneffector/parser" class="header-link">GitHub</a>
      </nav>
    </header>

    <div class="manual-layout">
      <aside class="manual-sidebar">
        <nav class="sidebar-nav">
<p><strong><a href="index.html">@motioneffector/parser</a></strong></p>
<p><strong>Getting Started</strong></p>
<ul>
<li><a href="installation.html">Installation</a></li>
<li><a href="your-first-parse.html">Your First Parse</a></li>
</ul>
<p><strong>Core Concepts</strong></p>
<ul>
<li><a href="concept-vocabulary.html">Vocabulary</a></li>
<li><a href="concept-verb-patterns.html">Verb Patterns</a></li>
<li><a href="concept-entity-resolution.html">Entity Resolution</a></li>
<li><a href="concept-parse-results.html">Parse Results</a></li>
<li><a href="concept-pronoun-tracking.html">Pronoun Tracking</a></li>
</ul>
<p><strong>Guides</strong></p>
<ul>
<li><a href="guide-parsing-commands.html">Parsing Commands</a></li>
<li><a href="guide-handling-disambiguation.html">Handling Disambiguation</a></li>
<li><a href="guide-custom-vocabulary.html">Custom Vocabulary</a></li>
<li><a href="guide-error-handling.html">Error Handling</a></li>
<li><a href="guide-using-partial-matching.html">Using Partial Matching</a></li>
</ul>
<p><strong>API Reference</strong></p>
<ul>
<li><a href="api-parser-configuration.html">Parser Configuration</a></li>
<li><a href="api-parser-instance.html">Parser Instance</a></li>
<li><a href="api-entity-resolution.html">Entity Resolution</a></li>
<li><a href="api-parse-results.html">Parse Results</a></li>
<li><a href="api-errors.html">Errors</a></li>
<li><a href="api-tokenization.html">Tokenization</a></li>
</ul>

        </nav>
      </aside>

      <main class="manual-content">
        <article class="manual-article">
<h1>Handling Disambiguation</h1>
<p>When your resolver returns multiple matching entities, the parser returns an <code>ambiguous</code> result instead of a command. This guide shows how to present choices to the player and complete the command.</p>
<h2>Prerequisites</h2>
<p>Before starting, you should:</p>
<ul>
<li><a href="concept-entity-resolution.html">Understand entity resolution</a></li>
<li><a href="concept-parse-results.html">Understand parse results</a></li>
</ul>
<h2>Overview</h2>
<p>We&#39;ll handle disambiguation by:</p>
<ol>
<li>Detecting ambiguous results</li>
<li>Presenting candidates to the player</li>
<li>Getting the player&#39;s choice</li>
<li>Completing the command</li>
</ol>
<h2>Step 1: Detect Ambiguous Results</h2>
<p>Check for <code>type: &#39;ambiguous&#39;</code> after parsing:</p>
<pre><code class="language-typescript">const result = parser.parse(&#39;get ball&#39;)

if (result.type === &#39;ambiguous&#39;) {
  // Multiple items matched &quot;ball&quot;
  console.log(result.candidates)  // [{ id: &#39;ball-red&#39; }, { id: &#39;ball-blue&#39; }]
  console.log(result.original)    // &#39;ball&#39;
  console.log(result.role)        // &#39;subject&#39; or &#39;object&#39;
}
</code></pre>
<h2>Step 2: Present Choices</h2>
<p>Show the candidates with a way to select:</p>
<pre><code class="language-typescript">function presentChoices(result: AmbiguousResult): string {
  const options = result.candidates
    .map((candidate, index) =&gt; {
      // Use name property if available, otherwise id
      const label = (candidate as { name?: string }).name || candidate.id
      return `  ${index + 1}) ${label}`
    })
    .join(&#39;\n&#39;)

  return `Which ${result.original}?\n${options}`
}
</code></pre>
<p>Output:</p>
<pre><code>Which ball?
  1) red ball
  2) blue ball
</code></pre>
<h2>Step 3: Get Player Choice</h2>
<p>Accept the player&#39;s selection. Common approaches:</p>
<pre><code class="language-typescript">// By number
function handleSelection(input: string, candidates: ResolvedEntity[]): ResolvedEntity | null {
  const num = parseInt(input, 10)
  if (num &gt;= 1 &amp;&amp; num &lt;= candidates.length) {
    return candidates[num - 1]!
  }
  return null
}

// By name/adjective
function handleSelectionByName(input: string, candidates: ResolvedEntity[]): ResolvedEntity | null {
  const lower = input.toLowerCase()
  return candidates.find(c =&gt; {
    const name = ((c as { name?: string }).name || c.id).toLowerCase()
    return name.includes(lower)
  }) || null
}
</code></pre>
<h2>Step 4: Complete the Command</h2>
<p>Once the player chooses, you have two options:</p>
<p><strong>Option A: Re-parse with more specific input</strong></p>
<pre><code class="language-typescript">// Player said &quot;red&quot; to clarify
const clarified = `get red ball`
const result = parser.parse(clarified)
</code></pre>
<p><strong>Option B: Construct the command directly</strong></p>
<pre><code class="language-typescript">function completeCommand(
  originalInput: string,
  selectedEntity: ResolvedEntity,
  role: &#39;subject&#39; | &#39;object&#39;
): Command {
  // Re-parse the original to get the verb
  const parsed = parser.parse(originalInput)

  if (parsed.type === &#39;ambiguous&#39;) {
    // Build command manually with selected entity
    return {
      verb: &#39;GET&#39;,  // You&#39;d extract this from original parsing context
      subject: {
        id: selectedEntity.id,
        noun: &#39;ball&#39;,
        adjectives: []
      },
      raw: originalInput
    }
  }

  // Shouldn&#39;t happen, but handle gracefully
  throw new Error(&#39;Expected ambiguous result&#39;)
}
</code></pre>
<h2>Complete Example</h2>
<pre><code class="language-typescript">import { createParser } from &#39;@motioneffector/parser&#39;
import type { AmbiguousResult, ParseResult, ResolvedEntity } from &#39;@motioneffector/parser&#39;

// Game state with ambiguous items
const items = [
  { id: &#39;ball-red&#39;, name: &#39;red ball&#39;, baseNoun: &#39;ball&#39; },
  { id: &#39;ball-blue&#39;, name: &#39;blue ball&#39;, baseNoun: &#39;ball&#39; },
  { id: &#39;lamp-1&#39;, name: &#39;lamp&#39;, baseNoun: &#39;lamp&#39; },
]

function resolver(noun: string, adjectives: string[]): ResolvedEntity[] {
  let matches = items.filter(item =&gt; item.baseNoun === noun)
  if (adjectives.includes(&#39;red&#39;)) {
    matches = matches.filter(item =&gt; item.name.includes(&#39;red&#39;))
  }
  if (adjectives.includes(&#39;blue&#39;)) {
    matches = matches.filter(item =&gt; item.name.includes(&#39;blue&#39;))
  }
  return matches
}

const parser = createParser({ resolver })

// State machine for disambiguation
let pendingAmbiguous: AmbiguousResult | null = null
let pendingVerb: string | null = null

function handleInput(input: string): string {
  // Check if we&#39;re waiting for disambiguation
  if (pendingAmbiguous) {
    return handleDisambiguation(input)
  }

  const result = parser.parse(input)

  switch (result.type) {
    case &#39;command&#39;:
      return executeCommand(result.command)

    case &#39;ambiguous&#39;:
      pendingAmbiguous = result
      pendingVerb = extractVerb(input)
      return formatChoices(result)

    case &#39;unknown_verb&#39;:
      return `I don&#39;t understand &quot;${result.verb}&quot;.`

    case &#39;unknown_noun&#39;:
      return `I don&#39;t see any &quot;${result.noun}&quot; here.`

    case &#39;parse_error&#39;:
      return result.message
  }
}

function handleDisambiguation(input: string): string {
  const selection = parseInt(input, 10)

  if (selection &gt;= 1 &amp;&amp; selection &lt;= pendingAmbiguous!.candidates.length) {
    const selected = pendingAmbiguous!.candidates[selection - 1]!
    const verb = pendingVerb!

    // Clear pending state
    pendingAmbiguous = null
    pendingVerb = null

    // Execute with selected entity
    return `You ${verb.toLowerCase()} the ${(selected as { name: string }).name}.`
  }

  return `Please enter a number between 1 and ${pendingAmbiguous!.candidates.length}.`
}

function formatChoices(result: AmbiguousResult): string {
  const lines = result.candidates.map((c, i) =&gt;
    `  ${i + 1}) ${(c as { name: string }).name}`
  )
  return `Which ${result.original}?\n${lines.join(&#39;\n&#39;)}`
}

function extractVerb(input: string): string {
  return input.split(&#39; &#39;)[0]!.toUpperCase()
}

function executeCommand(cmd: { verb: string; subject?: { id: string } }): string {
  return `You ${cmd.verb.toLowerCase()} the ${cmd.subject?.id || &#39;thing&#39;}.`
}

// Usage
console.log(handleInput(&#39;get ball&#39;))
// Which ball?
//   1) red ball
//   2) blue ball

console.log(handleInput(&#39;1&#39;))
// You get the red ball.
</code></pre>
<h2>Variations</h2>
<h3>Subject vs Object Disambiguation</h3>
<p>The <code>role</code> field tells you which part was ambiguous:</p>
<pre><code class="language-typescript">if (result.type === &#39;ambiguous&#39;) {
  if (result.role === &#39;subject&#39;) {
    // &quot;get ball&quot; - which ball to get?
    return `Which ${result.original} do you want to get?`
  } else {
    // &quot;put key in ball&quot; - which ball to put it in?
    return `Which ${result.original} do you want to put it in?`
  }
}
</code></pre>
<h3>Cancel Disambiguation</h3>
<p>Let players abort:</p>
<pre><code class="language-typescript">function handleDisambiguation(input: string): string {
  if (input.toLowerCase() === &#39;cancel&#39; || input.toLowerCase() === &#39;nevermind&#39;) {
    pendingAmbiguous = null
    return &#39;Okay, never mind.&#39;
  }
  // ... normal handling
}
</code></pre>
<h3>Re-parse Instead of State Machine</h3>
<p>Simpler approach if you can modify input:</p>
<pre><code class="language-typescript">function handleInput(input: string): string {
  const result = parser.parse(input)

  if (result.type === &#39;ambiguous&#39;) {
    // Ask player to be more specific
    return `Which ${result.original}? Try &quot;get red ball&quot; or &quot;get blue ball&quot;.`
  }

  // ... handle other cases
}
</code></pre>
<h2>Troubleshooting</h2>
<h3>Always Getting Ambiguous</h3>
<p><strong>Symptom:</strong> Every noun returns ambiguous</p>
<p><strong>Cause:</strong> Resolver returning all items instead of filtering</p>
<p><strong>Solution:</strong> Check resolver logic filters by noun and adjectives</p>
<h3>Wrong Entity Selected</h3>
<p><strong>Symptom:</strong> Selection returns wrong item</p>
<p><strong>Cause:</strong> Index mismatch (1-based vs 0-based)</p>
<p><strong>Solution:</strong> Remember candidates array is 0-indexed, but display is 1-indexed</p>
<h2>See Also</h2>
<ul>
<li><strong><a href="concept-entity-resolution.html">Entity Resolution</a></strong> - How matching works</li>
<li><strong><a href="guide-error-handling.html">Error Handling</a></strong> - Other result types</li>
<li><strong><a href="api-parse-results.html">Parse Results API</a></strong> - AmbiguousResult interface</li>
</ul>

        </article>
      </main>
    </div>
  </div>
</body>
</html>
